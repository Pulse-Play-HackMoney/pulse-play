## Phase 1 Complete: Monorepo + LMSR Engine + Market Manager + Position Tracker
Date: 2026-02-04

### What was done:
1. **Monorepo scaffolding** — pnpm workspaces with root package.json, pnpm-workspace.yaml, tsconfig.base.json, .gitignore
2. **packages/hub** — TypeScript + Jest setup with ts-jest
3. **LMSR Engine** (`packages/hub/src/modules/lmsr/`)
   - `types.ts` — Outcome type
   - `engine.ts` — Stateless LMSR functions: costFunction, getPrice, getCost, getShares (binary search inverse), getNewQuantities
   - Uses log-sum-exp trick for numerical stability with large quantities
   - `engine.test.ts` — 23 tests covering prices, costs, shares, quantities, b-sensitivity
4. **Market Manager** (`packages/hub/src/modules/market/`)
   - `types.ts` — Market, MarketStatus, ResolutionResult types
   - `manager.ts` — State machine (PENDING→OPEN→CLOSED→RESOLVED), market CRUD, resolution with position-based winner/loser calculation
   - `manager.test.ts` — 21 tests covering creation, valid transitions, invalid transitions, timestamps, resolution logic
5. **Position Tracker** (`packages/hub/src/modules/position/`)
   - `types.ts` — Position type
   - `tracker.ts` — In-memory position storage with market/user/specific queries and cleanup
   - `tracker.test.ts` — 10 tests covering add, query, clear

### Test results:
- **54 tests passing** across 3 test suites
- Command: `pnpm --filter hub test`

### Architecture decisions:
- LMSR engine is purely stateless functions (no class) — easy to test and compose
- MarketManager is a class holding market state in a Map — supports multiple markets
- PositionTracker is a class with in-memory array — simple and sufficient for MVP
- Market resolution takes positions as a parameter (loose coupling with PositionTracker)
- Binary search for getShares inverse (100 iterations, 1e-10 tolerance)

### Tech stack so far:
- pnpm 10.x workspaces
- TypeScript 5.6
- Jest 29 + ts-jest 29
- Node 20+

---

## Phase 2 Complete: Yellow Network / Clearnode Integration
Date: 2026-02-04

### What was done:
1. **Dependencies added** — @erc7824/nitrolite@^0.5.3, viem@^2.45.1, ws@^8.19.0, @types/ws
2. **Clearnode module** (`packages/hub/src/modules/clearnode/`)
   - `types.ts` — ClearnodeConfig, SubmitAppStateParams, CloseSessionParams, TransferParams, AppSessionAllocation
   - `rpc.ts` — sendAndWait() promise-based WebSocket correlator (adapted from yellow-quickstart)
   - `auth.ts` — 3-step EIP-712 auth flow: auth_request → auth_challenge → auth_verify
   - `faucet.ts` — requestFaucet() HTTP helper for sandbox token distribution
   - `client.ts` — ClearnodeClient class: connect, disconnect, isConnected, getBalance, requestFaucet, submitAppState, closeSession, transfer
   - `rpc.test.ts` — 6 tests (send, resolve, ignore, error, timeout, concurrent)
   - `auth.test.ts` — 6 tests (request, challenge, verify, signer return, request fail, verify fail)
   - `client.test.ts` — 24 tests (connection lifecycle 6, getBalance 4, faucet 2, submitAppState 4, closeSession 4, transfer 4)
   - `client.live.test.ts` — 6 live tests gated by LIVE_TEST=true (auth, faucet, balance, disconnect)
3. **Jest config updated** — Added moduleNameMapper to resolve .js imports for ESM-style TypeScript

### Test results:
- **90 mock tests passing** across 6 test suites
- **6 live tests skipped** (run with LIVE_TEST=true pnpm --filter hub test)
- Command: `pnpm --filter hub test`

### Architecture decisions:
- ClearnodeClient wraps all Clearnode operations behind a clean interface
- Auth flow generates ephemeral session keys (lightweight ECDSA for repeated RPC calls)
- sendAndWait correlates request/response by RPC method name, handles errors and timeouts
- Faucet is a standalone helper (reusable for bettor funding in Phase 3)
- Live tests use throwaway ephemeral wallets against sandbox — no cleanup needed
- Module imports use .js extensions (ESM convention) with Jest moduleNameMapper for resolution

### How PulsePlay uses these operations:
- Fund MM (test): requestFaucet()
- Bet rejected: closeSession() — return funds to user
- Loser resolution: submitAppState() (reallocate user→MM) → closeSession()
- Winner resolution: closeSession() (return bet) → transfer() (pay profit from MM→user)
- Check liquidity: getBalance() — MM's available funds

### Next steps (Phase 3):
- Hub REST + WebSocket APIs (Fastify)
- POST /api/bet, GET /api/market, POST /api/oracle/*, POST /api/faucet/*
- WebSocket broadcast for real-time odds/market updates
- Mock Oracle with auto-play mode
- Wire LMSR + Market + Position + Clearnode into API endpoints

---

## Phase 3 Complete: Hub REST + WebSocket APIs
Date: 2026-02-04

### What was done:
1. **Dependencies added** — fastify, @fastify/websocket
2. **API types** (`src/api/types.ts`) — Request/response DTOs, WebSocket message type unions (ODDS_UPDATE, MARKET_STATUS, GAME_STATE, BET_RESULT)
3. **OracleService** (`src/modules/oracle/`) — Game state management, auto-play mode with configurable timers and outcome sequences, callbacks for market lifecycle
4. **WsManager** (`src/api/ws.ts`) — WebSocket connection tracking with per-address mapping, broadcast(), sendTo(), cleanup on close
5. **AppContext** (`src/context.ts`) — Shared context interface + createTestContext() helper with mocked ClearnodeClient
6. **App factory** (`src/app.ts`) — buildApp(ctx) creates Fastify instance with all routes and WebSocket support
7. **Routes:**
   - `bet.routes.ts` — POST /api/bet (LMSR integration: getShares → getNewQuantities → updateQuantities → record position → broadcast odds)
   - `market.routes.ts` — GET /api/market, GET /api/market/:marketId (with computed LMSR prices)
   - `positions.routes.ts` — GET /api/positions/:address
   - `oracle.routes.ts` — POST /api/oracle/game-state, /market/open, /market/close, /outcome (full lifecycle with WS broadcasts + individual BET_RESULT messages)
   - `faucet.routes.ts` — POST /api/faucet/user (stub), POST /api/faucet/mm (calls ClearnodeClient)
   - `admin.routes.ts` — GET /api/admin/state, POST /api/admin/reset
8. **Server entry point** (`src/server.ts`) — Creates real context from env vars and listens on PORT

### Test results:
- **184 tests passing** across 15 test suites (90 existing Phase 1+2 + 94 new Phase 3)
- 6 live Clearnode tests skipped (run with LIVE_TEST=true)
- Integration tests use real WebSocket connections (app.listen on port 0)
- All route tests use Fastify's app.inject() — no port binding needed

### Test breakdown (Phase 3 new — 94 tests):
- oracle.test.ts: 11 (game state, auto-play, timers)
- ws.test.ts: 8 (broadcast, sendTo, cleanup, clear)
- bet.routes.test.ts: 15 (validation, LMSR integration, WS broadcast)
- market.routes.test.ts: 8 (prices, states, by-ID lookup)
- positions.routes.test.ts: 5 (query, filtering, field completeness)
- oracle.routes.test.ts: 23 (game state, open/close/resolve, WS notifications, BET_RESULT delivery)
- faucet.routes.test.ts: 6 (stub, validation, ClearnodeClient integration)
- admin.routes.test.ts: 6 (state dump, reset, auto-play stop)
- integration.test.ts: 12 (full lifecycle, concurrent bets, real WS, market cycling)

### Architecture decisions:
- AppContext is a mutable object — admin reset replaces MarketManager/PositionTracker instances in-place
- Oracle module-level marketCounter generates sequential market IDs (resettable for tests)
- WsManager uses readyState === 1 (numeric) to avoid import dependency on WebSocket constant
- Integration tests track open sockets and close them in afterEach to prevent worker leaks
- Route handlers return response objects directly (Fastify serializes to JSON automatically)

### Next steps (Phase 4):
- Frontend scaffolding (Next.js 14)
- Connect to Hub WebSocket for real-time updates
- Betting UI with LMSR price display
- Game state visualization

---

## Phase 4 Complete: Frontend Core
Date: 2026-02-04

### What was done:
1. **Next.js 14 scaffolding** — Created @pulse-play/frontend package with TypeScript, Tailwind, App Router
2. **Jest + testing-library setup** — Mock modules for wagmi, viem, @tanstack/react-query, WebSocket
3. **Lib modules** (`src/lib/`)
   - `config.ts` — env var exports (HUB_REST_URL, HUB_WS_URL, PRIVATE_KEY)
   - `types.ts` — mirrors hub API types (MarketResponse, PositionsResponse, WsMessage, etc.)
   - `api.ts` — Hub REST client (placeBet, getMarket, getPositions, oracle endpoints)
4. **Providers** (`src/providers/`)
   - `WagmiProvider.tsx` — wagmi config + QueryClient + WalletContext (address derived from PRIVATE_KEY)
   - `WebSocketProvider.tsx` — WebSocket connection management, subscribe pattern for real-time updates
   - `MarketProvider.tsx` — Market state management, syncs with REST + WebSocket
5. **Hooks** (`src/hooks/`)
   - `useBet.ts` — Bet placement with loading/error states
   - `usePositions.ts` — Position fetching with auto-refetch on market resolution
   - `useMarket.ts`, `useWebSocket.ts` — barrel re-exports
6. **Shared Components** (`src/components/`)
   - `Header.tsx` — Logo, navigation (Bettor/Oracle), WebSocket status, WalletStatus
   - `WalletStatus.tsx` — Shows truncated address or "not configured"
7. **Bettor Components** (`src/components/bettor/`)
   - `OddsDisplay.tsx` — Ball/Strike prices as percentages + American odds
   - `BetForm.tsx` — Outcome selection, amount input with presets, place bet button
   - `PositionList.tsx` — Shows user's positions in current market
   - `BetResultToast.tsx` — Win/Loss notification from WebSocket BET_RESULT
8. **Oracle Components** (`src/components/oracle/`)
   - `GameControls.tsx` — Activate/Deactivate game toggle
   - `MarketControls.tsx` — Open/Close market, Resolve with Ball/Strike
   - `StateDisplay.tsx` — System state dashboard (market, positions, connections)
9. **App Pages** (`src/app/`)
   - `layout.tsx` + `LayoutInner.tsx` — Provider nesting (WagmiProvider > WebSocketProvider > MarketProvider)
   - `page.tsx` — Bettor view (OddsDisplay, BetForm, PositionList)
   - `oracle/page.tsx` — Oracle panel (GameControls, MarketControls, StateDisplay)
10. **Hub CORS** — Added @fastify/cors to hub for frontend cross-origin requests

### Test results:
- **67 tests passing** across 15 test suites
- Command: `pnpm --filter @pulse-play/frontend test`
- Build passes: `pnpm --filter @pulse-play/frontend build`

### Test breakdown (67 tests):
- lib/api: 9
- providers: 12 (WagmiProvider 3, WebSocketProvider 4, MarketProvider 5)
- hooks: 10 (useBet 5, usePositions 5)
- components/shared: 6 (Header 3, WalletStatus 3)
- components/bettor: 17 (OddsDisplay 4, BetForm 5, PositionList 4, BetResultToast 4)
- components/oracle: 13 (GameControls 4, MarketControls 5, StateDisplay 3)

### Architecture decisions:
- WagmiProvider uses viem's privateKeyToAccount for direct wallet; no connector dependencies
- WebSocket reconnects after 3 seconds on disconnect
- MarketProvider refetches on OPEN/RESOLVED status changes (not CLOSED)
- BetResultToast uses subscribe pattern to avoid prop drilling
- All components have data-testid attributes for testing
- Test mocks for wagmi/viem/react-query avoid ESM import issues in Jest

### Environment setup:
- Copy `.env.local.example` to `.env.local`
- Set `NEXT_PUBLIC_PRIVATE_KEY` to a test wallet private key

### Running the full stack:
1. Terminal 1: `pnpm --filter hub build && node packages/hub/dist/server.js`
2. Terminal 2: `pnpm --filter @pulse-play/frontend dev`
3. Open http://localhost:3000 (Bettor) or http://localhost:3000/oracle (Oracle)

### Next steps (Phase 5):
- Remaining personas (Bettor wallet connection, proper session management)
- E2E integration tests
- Demo polish

---

## MetaMask Wallet Connection with Environment Toggle
Date: 2026-02-05

### What was done:
1. **Config update** (`packages/frontend/src/lib/config.ts`)
   - Added `WalletMode` type ('metamask' | 'private-key')
   - Added `WALLET_MODE` export from `NEXT_PUBLIC_WALLET_MODE` env var (default: 'private-key')

2. **Jest mock for wagmi/connectors** (`src/test/mocks/wagmiConnectors.ts`)
   - New mock file with `injected()` connector export

3. **Jest config update** (`jest.config.js`)
   - Added `'^wagmi/connectors$'` module mapping

4. **wagmi mock update** (`src/test/mocks/wagmiModule.ts`)
   - Added test utilities: `__setMockAccountState`, `__setMockConnectFn`, `__setMockDisconnectFn`, `__resetMocks`
   - Imports injected connector from wagmiConnectors mock

5. **WagmiProvider refactor** (`src/providers/WagmiProvider.tsx`)
   - Extended WalletContextValue interface with: `mode`, `isConnecting`, `isConnected`, `connect`, `disconnect`
   - Added `WalletContextProviderInner` component that uses wagmi hooks (useAccount, useConnect, useDisconnect)
   - Conditional logic: MetaMask mode uses wagmi hooks, private-key mode uses static account
   - Connect finds injected connector and calls wagmi connect
   - Provider nesting: WagmiProviderBase → QueryClientProvider → WalletContextProviderInner

6. **WalletStatus update** (`src/components/WalletStatus.tsx`)
   - MetaMask mode, not connected: Shows "Connect Wallet" button
   - MetaMask mode, connecting: Shows "Connecting..." disabled button
   - MetaMask mode, connected: Shows address + "Disconnect" button
   - Private-key mode: Keeps existing behavior (no connect/disconnect buttons)

7. **Tests updated**
   - `WagmiProvider.test.tsx`: 6 tests for new context fields and behaviors
   - `WalletStatus.test.tsx`: Expanded to 11 tests covering both modes

8. **Environment documentation** (`.env.local.example`)
   - Documented `NEXT_PUBLIC_WALLET_MODE` with mode options

### Test results:
- **77 tests passing** across 15 test suites (was 67)
- Command: `pnpm --filter @pulse-play/frontend test`

### Breaking changes:
- None — `useWallet()` remains backwards compatible
- `address` and `isConfigured` still work as before
- New fields (`mode`, `isConnecting`, `isConnected`, `connect`, `disconnect`) added with sensible defaults

### Usage:
```bash
# Private-key mode (default) - existing behavior
NEXT_PUBLIC_WALLET_MODE=private-key
NEXT_PUBLIC_PRIVATE_KEY=0x...

# MetaMask mode - browser wallet connection
NEXT_PUBLIC_WALLET_MODE=metamask
```

### Notes:
- Module-level config evaluation means WALLET_MODE is read once at import time
- MetaMask mode tests would require Jest module isolation (complex), so coverage is via integration testing
- WagmiProvider test file simplified to avoid react multiple-instance issues with jest.doMock


### Build fix:
- Changed import from `wagmi/connectors` to main `wagmi` export for `injected` connector
- `wagmi/connectors` barrel imports porto module which has missing peer dependency
- Removed separate wagmiConnectors.ts mock file (injected now in wagmiModule.ts)
- Removed `^wagmi/connectors$` mapping from jest.config.js


---

## Terminal Developer Dashboard
Date: 2026-02-05

### What was done:
1. **New package created** — `@pulse-play/dashboard` with Ink + React for terminal UI
2. **Package dependencies** — ink@^4.4.1, ink-spinner@^5.0.0, react@^18.2.0, chalk@^5.3.0, ws@^8.19.0
3. **Hooks** (`src/hooks/`)
   - `useWebSocket.ts` — WebSocket connection with auto-reconnect (3s delay, max 10 attempts)
   - `useAdminState.ts` — REST polling for `/api/admin/state` and `/api/admin/positions/:marketId`
4. **Components** (`src/components/`)
   - `MarketPanel.tsx` — Market status, LMSR prices with American odds
   - `PositionsPanel.tsx` — Position list with truncated addresses
   - `EventLog.tsx` — Scrolling WebSocket event log with timestamps
   - `SystemInfo.tsx` — WS/API status, client count, game state
5. **Main App** (`src/App.tsx`)
   - 2-column layout with border boxes
   - Aggregates state from hooks
   - 'q' keypress to quit
6. **Entry point** (`src/index.tsx`)
   - CLI argument parsing for custom hub URL
   - Help flag support
   - Shebang for direct execution
7. **Formatters** (`src/utils/formatters.ts`)
   - formatOdds, formatAmericanOdds, truncateAddress, formatTime
   - formatWsMessage, getStatusColor, getOutcomeColor
   - formatDollars, formatShares
8. **Hub enhancement** — Added `GET /api/admin/positions/:marketId` endpoint to admin.routes.ts

### Test results:
- **23 dashboard tests** (all formatters)
- **187 hub tests** (was 184, +3 new admin position endpoint tests)
- Command: `pnpm --filter @pulse-play/dashboard test`

### Test breakdown (dashboard — 23 tests):
- formatOdds: 5
- formatAmericanOdds: 4
- truncateAddress: 2
- formatTime: 1
- formatWsMessage: 6
- getStatusColor: 1
- getOutcomeColor: 2
- formatDollars: 1
- formatShares: 1

### Running the dashboard:
```bash
# Terminal 1: Start hub
cd packages/hub && pnpm dev

# Terminal 2: Start dashboard
cd packages/dashboard && pnpm dev

# Or with custom URL
cd packages/dashboard && pnpm dev http://192.168.1.100:3001
```

### Architecture notes:
- Dashboard is a separate CLI process (not in-process with hub)
- Connects via WebSocket for real-time events, polls REST for state
- LMSR price calculation duplicated in App.tsx for local updates from polled state
- Event log is capped at 100 entries (FIFO)
- Positions panel shows max 5 positions

### Next steps:
- Live integration testing with hub
- E2E verification of full stack (hub + frontend + dashboard)

### Test fixes (during dashboard implementation):
- Fixed `BetForm.test.tsx` — changed `'Ball'` to `'BALL'` (uppercase as per types.ts)
- Fixed `MarketControls.test.tsx` — changed `'Ball'` to `'BALL'` (uppercase as per types.ts)
- These were pre-existing bugs from a previous outcome terminology refactor

### Final test counts:
- **Hub**: 189 passed (6 live tests skipped)
- **Frontend**: 77 passed
- **Dashboard**: 23 passed
- **Total**: 289 passing tests


---

## Dashboard Refactor: Polling → WebSocket
Date: 2026-02-05

### Problem
The dashboard was polling `/api/admin/state` every 1 second, filling backend logs unnecessarily.

### Solution
Replaced REST polling with WebSocket-based state synchronization.

### New WebSocket Message Types (hub/src/api/types.ts)
1. **POSITION_ADDED** — Broadcast when a bet creates a position
   - Contains full position object + total position count
2. **CONNECTION_COUNT** — Broadcast on connect/disconnect
   - Contains current count of WebSocket clients
3. **STATE_SYNC** — Sent to newly connected clients
   - Contains full AdminStateResponse + positions array

### Hub Changes
- `types.ts` — Added 3 new WsMessage types, updated union type
- `ws.ts` — Added broadcastConnectionCount() on connect/disconnect, added sendToSocket() method
- `app.ts` — Send STATE_SYNC to new WebSocket connections
- `bet.routes.ts` — Broadcast POSITION_ADDED after recording position

### Dashboard Changes
- `types.ts` — Mirrored new WsMessage types
- `App.tsx` — Completely refactored to derive state from WebSocket messages:
  - STATE_SYNC initializes full state on connect
  - POSITION_ADDED adds to positions list
  - CONNECTION_COUNT updates client count
  - MARKET_STATUS/GAME_STATE/ODDS_UPDATE update respective state
  - Removed useAdminState import and REST polling
- `index.tsx` — Removed restUrl prop (no longer needed)
- `formatters.ts` — Added formatting for new message types
- `hooks/index.ts` — Removed useAdminState export (deprecated)

### Test Updates
- `ws.test.ts` — Updated 8 tests to account for CONNECTION_COUNT broadcasts, added 4 new tests
- `formatters.test.ts` — Added 3 tests for new message type formatting

### Test Results
- **Hub:** 192 passed (was 187, +5 new WS tests)
- **Frontend:** 77 passed
- **Dashboard:** 26 passed (was 23, +3 formatter tests)
- **Total:** 295 passing tests

### Benefits
- No more polling logs in backend
- Real-time state updates via WebSocket
- Lower backend load
- Simpler dashboard architecture (single data source)

---

## Frontend Refactor: StateDisplay Polling → WebSocket
Date: 2026-02-05

### Problem
The frontend's StateDisplay component (Oracle view) was polling `/api/admin/state` every 5 seconds, duplicating the same issue that was fixed in the dashboard.

### Solution
Extended the frontend's MarketProvider to handle all WebSocket message types and provide admin state to StateDisplay via context.

### Frontend Types Changes (src/lib/types.ts)
- Added `address` field to Position interface
- Added 3 new WebSocket message types (mirroring hub):
  - `WsPositionAdded` — position + positionCount
  - `WsConnectionCount` — count
  - `WsStateSync` — full AdminStateResponse + positions
- Updated `WsMessage` union type

### MarketProvider Changes (src/providers/MarketProvider.tsx)
- Added `positionCount` and `connectionCount` to MarketState
- Handle new WebSocket message types:
  - `STATE_SYNC` — Initialize market, prices, gameActive, positionCount, connectionCount
  - `CONNECTION_COUNT` — Update connectionCount
  - `POSITION_ADDED` — Update positionCount
- Exposed new values in context

### StateDisplay Changes (src/components/oracle/StateDisplay.tsx)
- Removed useState for market, gameState, positionCount, connectionCount
- Removed useEffect with setInterval polling
- Removed fetchState() REST function
- Now gets all state from useMarket() hook
- Same UI rendering logic preserved

### Test Fixes
- Updated all test files to use uppercase 'BALL'/'STRIKE' (was 'Ball'/'Strike'):
  - `usePositions.test.tsx` — 4 occurrences
  - `api.test.ts` — 5 occurrences
  - `MarketProvider.test.tsx` — 1 occurrence
- Added missing `address` field to Position mocks in tests

### Test Results
- **Hub:** 192 passed
- **Frontend:** 81 passed (was 77, +4 new MarketProvider context tests)
- **Dashboard:** 26 passed
- **Total:** 299 passing tests

### Benefits
- Oracle StateDisplay now updates instantly via WebSocket
- Eliminated /api/admin/state polling from frontend
- Consistent state sync architecture across dashboard and frontend
- All state flows through WebSocket → MarketProvider → components

---

## Fix: Dashboard market-id not updating & odds not resetting on new market
Date: 2026-02-05

### Bugs Fixed

**Bug 1: Dashboard market-id not updating**
- MARKET_STATUS handler in `dashboard/src/App.tsx` spread `prev.market` without updating `id`
- When market-2 opened, dashboard still showed market-1's ID

**Bug 2: Odds not resetting on new market**
- No ODDS_UPDATE broadcast when a new market opened (hub)
- Dashboard & frontend preserved old `qBall`/`qStrike` values via spread
- Old odds persisted because only bets triggered ODDS_UPDATE

### Changes

1. **Hub (`oracle.routes.ts`)** — Added `getPrice` import and ODDS_UPDATE broadcast after MARKET_STATUS in market open handler. New market now broadcasts both MARKET_STATUS(OPEN) and ODDS_UPDATE(0.5/0.5).

2. **Dashboard (`App.tsx`)** — Rewrote MARKET_STATUS handler to detect new market by comparing `prev.market.id !== msg.marketId`. When new: creates fresh market object, clears positions, resets prices to 50/50. When same market: updates status/outcome and always copies `msg.marketId`.

3. **Frontend (`MarketProvider.tsx`)** — Rewrote MARKET_STATUS handler with same new-market detection. When new market: resets qBall/qStrike/b, prices to 50/50, positionCount to 0. Always copies `message.marketId` into market state. Still triggers refetch on OPEN/RESOLVED.

### Tests Added
- Hub: +1 test — `broadcasts ODDS_UPDATE with 50/50 prices on market open`
- Frontend: +2 tests — `updates market ID when MARKET_STATUS arrives with new marketId`, `resets prices and positionCount for new market`

### Test Results
- **Hub:** 193 passed (was 192)
- **Frontend:** 83 passed (was 81)
- **Dashboard:** 26 passed (unchanged)
- **Total:** 302 passing tests

---

## Fix: Double WebSocket Connection in Frontend (StrictMode)
Date: 2026-02-05

### Root Cause
React StrictMode double-invokes effects in development: mount → unmount → mount. The cleanup function called `ws.close()`, which fired `onclose` and scheduled a reconnect via `setTimeout(connect, 3000)`. Since `reconnectTimeoutRef` was already `null` at that point, the orphaned timeout was never cleared. Result: two connections per address (one immediate from re-mount, one 3 seconds later from orphaned reconnect).

### Fix
Added `intentionalClose` closure variable in the `useEffect`. Set to `true` in the cleanup function **before** calling `ws.close()`. The `onclose` handler checks this flag and skips reconnection when the close was intentional.

### Files Changed
- `packages/frontend/src/providers/WebSocketProvider.tsx` — added `intentionalClose` guard
- `packages/frontend/src/providers/WebSocketProvider.test.tsx` — added cleanup test

### Test Results
- **Frontend:** 84 passed (was 83, +1 new cleanup test)
- **Total:** 303 passing tests

---

## Market Maker Overview Page
Date: 2026-02-05

### What was done:

#### Hub Changes
1. **types.ts** — Added `MMFaucetRequest` (optional count) and `MMInfoResponse` (address, balance, isConnected)
2. **logger.ts** — Updated `faucetMM()` signature to include count parameter; added `mmInfoFetched()` method
3. **mm.routes.ts** (new) — `GET /api/mm/info` returns MM wallet address, balance, and connection status
4. **faucet.routes.ts** — Modified `POST /api/faucet/mm` to accept `{ count?: number }` (default 1, capped at 50). Loops count times calling `requestFaucet()`. Returns partial results on mid-loop failure.
5. **app.ts** — Registered `registerMMRoutes(app, ctx)`
6. **mm.routes.test.ts** (new) — 2 tests (info endpoint success + error handling)
7. **faucet.routes.test.ts** — Added 4 new tests (count=3, no body default, count>50 rejection, partial failure)

#### Frontend Changes
1. **types.ts** — Added `MMInfoResponse` and `MMFaucetResponse` interfaces
2. **api.ts** — Added `getMMInfo()` and `requestMMFaucet(count)` functions
3. **api.test.ts** — Added 3 tests for new API functions
4. **Header.tsx** — Added "Market Maker" nav link with `data-testid="nav-market-maker"`
5. **Header.test.tsx** — Updated to verify Market Maker link presence
6. **market-maker/page.tsx** (new) — Page with 2-column grid (2/3 + 1/3): MMFaucetCard left, MMBalanceCard right. Uses refreshKey pattern for faucet→balance refresh.
7. **market-maker/MMBalanceCard.tsx** (new) — Displays truncated address (copy-to-clipboard), balance formatted as $ (raw/1,000,000), connection status badge, refresh button. Loading skeleton + error states.
8. **market-maker/MMFaucetCard.tsx** (new) — Preset amounts ($10, $50, $100, $500), custom input (multiples of $10), divides by 10 for count. Shows success/warning/error states. Calls onFunded callback for balance refresh.
9. **market-maker/index.ts** (new) — Barrel export
10. **MMBalanceCard.test.tsx** (new) — 5 tests (loading, display, refresh, error, disconnected)
11. **MMFaucetCard.test.tsx** (new) — 9 tests (presets, selection, custom input, submit, loading, success, partial failure, error, onFunded callback)

### Test Results
- **Hub:** 199 passed (was 193, +6 new: 2 mm routes + 4 faucet batch)
- **Frontend:** 104 passed (was 84, +20 new: 3 api + 1 header + 5 balance + 9 faucet + 2 unused)
- **Dashboard:** 26 passed (unchanged)
- **Total:** 329 passing tests

### Architecture Notes
- MMBalanceCard uses `refreshKey` prop to trigger re-fetch after faucet funding
- Balance formatted by dividing raw string by 1,000,000 (ytest.usdc uses 6 decimals)
- Faucet batch: count = selectedAmount / 10 (each faucet request = $10 ytest.usdc)
- Partial failure returns `{ success: true, funded: N, requested: count, error: string }` — no 500 if at least one succeeded

---

## Fix: GET /api/mm/info crash when ClearnodeClient disconnected
Date: 2026-02-05

### Problem
`GET /api/mm/info` threw 500 with `"ClearnodeClient is not connected"` because `getBalance()` calls `assertConnected()` internally. When the hub starts without Clearnode credentials or the WebSocket hasn't connected, the endpoint crashed.

### Fix
- Check `isConnected()` before calling `getBalance()`. When disconnected, return `balance: "0"` instead of crashing.
- Moved `isConnected` check before `getBalance` call so it gates the balance fetch.

### Files Changed
- `packages/hub/src/api/mm.routes.ts` — Reordered: get address → check isConnected → conditionally get balance
- `packages/hub/src/api/mm.routes.test.ts` — Added test: disconnected case returns 200 with `{ address: "0xMM", balance: "0", isConnected: false }`

### Test Results
- **Hub:** 200 passed (was 199, +1 new disconnected test)
- **Total:** 330 passing tests

---

## Fix: Connect ClearnodeClient on server startup
Date: 2026-02-05

### Problem
`clearnodeClient.connect()` was never called in `server.ts`. The client was constructed but the WebSocket + EIP-712 auth handshake was never initiated, meaning `isConnected()` was always `false` in production and all WebSocket-dependent operations would fail.

### Fix
1. **server.ts** — Added `await clearnodeClient.connect()` after `app.listen()` in a try/catch. On success logs `clearnodeConnected`, on failure logs error + `clearnodeDisconnected`. Server stays up either way (degraded mode — faucet HTTP still works, `mm/info` returns `balance: "0"`).
2. **logger.ts** — Added `clearnodeConnected(address)` and `clearnodeDisconnected()` methods with ANSI formatting.
3. **logger.test.ts** — Added both methods to existing test blocks (callable + no stdout in test env).
4. **context.ts** — Verified: mock already had `connect` and `disconnect` — no changes needed.

### Test Results
- **Hub:** 200 passed (unchanged count, existing tests still pass)
- **Total:** 330 passing tests

---

## Frontend ClearnodeProvider Implementation
Date: 2026-02-05

### What was done:
Implemented a `ClearnodeProvider` that authenticates the bettor's wallet with the Yellow Network Clearnode on wallet connect, obtains a session key, and exposes the signer/WS for future Clearnode operations.

#### New files:
1. **`lib/clearnode/types.ts`** — `ClearnodeStatus`, `ClearnodeContextValue`, `AuthResult` types
2. **`lib/clearnode/rpc.ts`** — Browser-compatible `sendAndWaitBrowser()` and `openClearnodeWs()` (ported from yellow-quickstart)
3. **`lib/clearnode/auth.ts`** — Browser-compatible 3-step EIP-712 auth (`authenticateBrowser()`) mirroring hub's auth.ts
4. **`lib/clearnode/index.ts`** — Barrel re-export
5. **`providers/ClearnodeProvider.tsx`** — React context provider with auto-auth on wallet connect, balance fetch, reconnect/disconnect
6. **`hooks/useClearnode.ts`** — Convenience hook re-export
7. **`test/mocks/nitroliteModule.ts`** — Jest mock for `@erc7824/nitrolite` SDK

#### Test files:
- `lib/clearnode/rpc.test.ts` — 8 tests (sendAndWaitBrowser: resolve, ignore non-matching, RPC error, timeout, cleanup, unparseable; openClearnodeWs: resolve on open, reject on error)
- `lib/clearnode/auth.test.ts` — 6 tests (full 3-step flow, no account, verify fail, propagate errors, custom config, default config)
- `providers/ClearnodeProvider.test.tsx` — 10 tests (disconnected, auto-auth, balance fetch, WS fail, auth fail, ws ref, disconnect cleanup, reconnect, unmount cleanup, balance fetch fail)

#### Modified files:
- **`package.json`** — Added `@erc7824/nitrolite@^0.5.3` dependency
- **`jest.config.js`** — Added `@erc7824/nitrolite` and `viem/chains` module name mappers
- **`lib/config.ts`** — Added `CLEARNODE_URL` export
- **`test/mocks/wagmiModule.ts`** — Added `useWalletClient` mock + `__setMockWalletClient()` test utility
- **`test/mocks/viemModule.ts`** — Updated `createWalletClient` to accept options including account
- **`app/LayoutInner.tsx`** — Inserted `ClearnodeProvider` between `WagmiProvider` and `WebSocketProvider`
- **`providers/index.ts`** — Added ClearnodeProvider + useClearnode exports
- **`.env.local.example`** — Added `NEXT_PUBLIC_CLEARNODE_URL`

### Provider hierarchy:
```
WagmiProvider              (wallet: MetaMask or private-key)
  ClearnodeProvider        (Clearnode WS auth, session key, balance)
    WebSocketProvider      (Hub WS: market updates)
      MarketProvider       (market state)
```

### Context interface:
```typescript
interface ClearnodeContextValue {
  status: 'disconnected' | 'connecting' | 'authenticating' | 'connected' | 'error';
  error: string | null;
  isSessionValid: boolean;
  signer: MessageSigner | null;
  ws: WebSocket | null;
  balance: string | null;
  refreshBalance: () => Promise<void>;
  reconnect: () => Promise<void>;
  disconnect: () => void;
}
```

### Auth flow:
- Private-key mode: auto-creates WalletClient from env var, signs EIP-712 automatically
- MetaMask mode: waits for wagmi's useWalletClient to be available, then delegates signing to MetaMask
- Both modes: opens WS → 3-step EIP-712 auth → stores session signer → fetches balance
- Session expiry tracked via `expiresAt` + `isSessionValid` computed property

### Test Results
- **Frontend:** 128 passed (was 104, +24 new: 8 rpc + 6 auth + 10 provider)
- **Total:** 354 passing tests

---

## User Account Page Implementation
Date: 2026-02-05

### What was done:
Implemented the `/account` page with 3 cards: Session management, Faucet funding, and Balance display.

#### Hub Changes
1. **types.ts** — Changed `FaucetRequest` from `{ address, amount }` to `{ address, count? }` (count-based like MM faucet)
2. **faucet.routes.ts** — Rewrote `POST /api/faucet/user` to call `requestFaucet(address)` from clearnode/faucet.ts in a loop. Accepts `{ address, count? }` (default 1, max 50). Returns `{ success, funded }` or partial failure with `{ success, funded, requested, error }`.
3. **logger.ts** — Updated `faucetUser()` to match count-based pattern: `faucetUser(address, count?, error?)`
4. **faucet.routes.test.ts** — Rewrote user faucet tests (7 tests: success, missing address, count=3, default count, count>50, partial failure, total failure). Mock of `requestFaucet` module added.
5. **logger.test.ts** — Updated faucetUser test calls to match new signature.

#### Frontend: ClearnodeProvider Updates
1. **lib/clearnode/types.ts** — Added `expiresAt`, `allowanceAmount`, `setAllowanceAmount` to `ClearnodeContextValue`
2. **providers/ClearnodeProvider.tsx** — Added `allowanceAmount` state (default 1000), `setAllowanceAmount` setter, exposed `expiresAt` in context. Passes custom allowance to `authenticateBrowser()`.
3. **providers/ClearnodeProvider.test.tsx** — Added 4 tests: expiresAt exposed, allowanceAmount default, setAllowanceAmount updates, allowance passed to auth

#### Frontend: API + Types
1. **lib/types.ts** — Added `UserFaucetResponse` interface
2. **lib/api.ts** — Added `requestUserFaucet(address, count?)` function
3. **lib/api.test.ts** — Added 2 tests for requestUserFaucet

#### Frontend: Account Components (new)
1. **components/account/SessionCard.tsx** — Session status badge (Active/Expired/Connecting/Error/Not Authenticated), expiry time display, allowance input, re-authenticate button
2. **components/account/AccountBalanceCard.tsx** — Balance display ($X.XX from raw/1M), refresh button, not-connected state
3. **components/account/AccountFaucetCard.tsx** — Preset amounts ($10/$50/$100/$500), custom input (multiples of $10), calls requestUserFaucet + refreshBalance, success/warning/error states
4. **components/account/index.ts** — Barrel export

#### Frontend: Page + Navigation
1. **app/account/page.tsx** — 3-card layout: SessionCard (full width), FaucetCard (2/3), BalanceCard (1/3). Uses refreshKey pattern.
2. **components/Header.tsx** — Added "Account" nav link with data-testid="nav-account"
3. **components/Header.test.tsx** — Updated to verify Account link presence

#### Test Files (new)
- `SessionCard.test.tsx` — 10 tests (status badges, expiry, reconnect, disabled state, allowance input)
- `AccountBalanceCard.test.tsx` — 5 tests (not-connected, balance display, null balance, refresh, large balance)
- `AccountFaucetCard.test.tsx` — 9 tests (presets, selection, custom input, submit, loading, success, partial failure, error, onFunded + refreshBalance callback)

### Test Results
- **Hub:** 204 passed (was 200, +4 new user faucet route tests)
- **Frontend:** 158 passed (was 128, +30 new: 4 provider + 2 api + 10 session + 5 balance + 9 faucet)
- **Dashboard:** 26 passed (unchanged)
- **Total:** 388 passing tests

### Architecture Notes
- User faucet routes through hub (avoids CORS issues with sandbox faucet direct call)
- Allowance is stored in ClearnodeProvider state; changing it requires re-authentication
- Session expiry and validity exposed in context for UI display
- AccountFaucetCard calls both onFunded callback (refreshKey) and refreshBalance (Clearnode balance)
- Same refreshKey pattern as MM page for faucet → balance refresh coordination

---

## Dashboard Upgrade: Fullscreen Interactive TUI
Date: 2026-02-05

### What was done:
Upgraded the `packages/dashboard/` terminal app from a simple read-only view to a fullscreen, interactive TUI with alternate screen buffer, dynamic sizing, panel navigation, scrollable panels, vim-style command bar, and visual price bars.

### New files:
1. **`hooks/useTerminalSize.ts`** — Hook returning `{ columns, rows }` from `process.stdout`, updates on resize, fallback 80x24
2. **`components/PriceBar.tsx`** — ASCII progress bar (`█░`) for BALL/STRIKE odds visualization
3. **`components/CommandBar.tsx`** — Footer component: keybinding hints (normal), command input (command mode), status messages
4. **`components/HelpOverlay.tsx`** — Keybinding reference screen (press `?` to toggle)

### Modified files:
1. **`hooks/useWebSocket.ts`** — Added `reconnect()` to `UseWebSocketResult` interface and return value
2. **`utils/formatters.ts`** — Added `renderPriceBar(probability, width)` pure function
3. **`index.tsx`** — Alternate screen buffer enter/exit (`\x1b[?1049h/l`), cursor hide/show, signal handlers (SIGINT, SIGTERM, uncaughtException), passes `hubUrl` prop to App
4. **`App.tsx`** — Major rewrite:
   - Fullscreen layout with `height={rows}` from useTerminalSize
   - Panel navigation (Tab to switch, j/k to scroll, g/G for top/bottom)
   - Command mode (`:clear`, `:reset`, `:reconnect`, `:quit`)
   - Help mode (press `?`)
   - Auto-scroll event log to bottom (disabled when user manually scrolls up, re-enabled on `G`)
   - Dynamic visible count calculation based on terminal rows
   - Price bar width derived from `columns / 2 - 6`
5. **`components/MarketPanel.tsx`** — Replaced plain text odds with PriceBar components, accepts `barWidth` prop
6. **`components/PositionsPanel.tsx`** — Scrollable with `scrollOffset`/`visibleCount`/`isActive` props, cyan border when active, scroll indicator
7. **`components/EventLog.tsx`** — Same scrollable pattern as PositionsPanel, chronological order (oldest first)
8. **`components/SystemInfo.tsx`** — Added `flexShrink={0}` for layout stability
9. **`components/index.ts`** — Added PriceBar, CommandBar, HelpOverlay exports
10. **`hooks/index.ts`** — Added useTerminalSize export
11. **`README.md`** — Updated with new layout diagram, controls tables, commands, architecture notes

### Test Results:
- **Dashboard:** 33 passed (was 26, +7 new renderPriceBar tests)
- TypeScript: zero errors (`tsc --noEmit` clean)

### Controls:
- **Tab** — Switch active panel (Positions ↔ Event Log)
- **j/↓, k/↑** — Scroll active panel
- **g/G** — Top/bottom of active panel
- **?** — Toggle help overlay
- **:** — Enter command mode
- **q** — Quit
- **:clear/:c** — Clear event log
- **:reset/:r** — POST /api/admin/reset
- **:reconnect** — Reconnect WebSocket
- **:quit/:q** — Quit

### Architecture Notes:
- Alternate screen buffer ensures terminal history is preserved
- `useTerminalSize` listens to `process.stdout.on('resize')` for dynamic layout
- Event log auto-scrolls to bottom unless user manually scrolled up; pressing `G` re-enables auto-scroll
- `reconnect()` in useWebSocket closes current WS, clears timeout, resets attempts, and reconnects
- `renderPriceBar()` is a pure function for testability — PriceBar component just renders its output
- No new npm dependencies required

---

## Clearnode Client Methods: Hub + Frontend
Date: 2026-02-05

### What was done:
Added `createAppSession`, `getAppSessions` to the Hub ClearnodeClient, and a full set of pure RPC method functions for the Frontend. Integrated all methods into the ClearnodeProvider context.

### Hub Changes
1. **types.ts** — Added `CreateAppSessionParams`, `CreateAppSessionResult`, `AppSessionInfo` interfaces
2. **client.ts** — Added `createAppSession()` and `getAppSessions()` methods with new nitrolite SDK imports (`createAppSessionMessage`, `parseCreateAppSessionResponse`, `createGetAppSessionsMessage`, `parseGetAppSessionsResponse`, `RPCProtocolVersion`, `RPCChannelStatus`)
3. **client.test.ts** — Added 8 tests in 2 new describe blocks: createAppSession (4 tests), getAppSessions (4 tests)
4. **context.ts** — Added `createAppSession` and `getAppSessions` to mockClearnode in `createTestContext()`

### Frontend Changes
1. **lib/clearnode/methods.ts** (new) — 6 pure async RPC functions: `createAppSession`, `closeAppSession`, `submitAppState`, `transfer`, `getAppSessions`, `getConfig`. Each takes `(ws, signer, ...)` — testable without React.
2. **lib/clearnode/methods.test.ts** (new) — 17 tests covering all 6 methods (correct SDK calls, return values, throws when not connected)
3. **test/mocks/nitroliteModule.ts** — Added 14 new mock exports for all app session, state, transfer, config SDK functions + RPCAppStateIntent and RPCProtocolVersion enums
4. **lib/clearnode/index.ts** — Added `export * from './methods'`
5. **lib/clearnode/types.ts** — Extended `ClearnodeContextValue` with 6 new method signatures
6. **providers/ClearnodeProvider.tsx** — Added 6 useCallback wrappers that capture wsRef/signer/address, updated default context with error-throwing stubs
7. **providers/ClearnodeProvider.test.tsx** — Added 6 tests verifying each method delegates correctly when connected

### Also fixed:
- Removed unused `waitFor` import from `SessionCard.test.tsx` (pre-existing lint issue)

### Test Results
- **Hub:** 212 passed (was 204, +8 new clearnode client tests)
- **Frontend:** 181 passed (was 158, +17 methods + 6 provider)
- **Frontend build:** ✅ succeeds
- **Total:** 393+ passing tests

### Architecture Notes
- Frontend methods are pure functions (not hooks/components) for easier testing
- `getConfig` uses V2 variant (synchronous, no signer needed)
- `createAppSession` defaults to `pulse-play` application, NitroRPC/0.4 protocol, weights [0, 100] quorum 100 (bettor has 0 weight, MM has 100 = full control)
- All methods use `assertReady()` guard that checks WS readyState and signer presence
- Provider uses `useCallback` with dependency on `signer` and `address` for React memoization

---

## Bug Fixes: Account Page Issues
Date: 2026-02-05

### Bug 1: Allowance input triggers re-authentication on every keystroke
**Root cause:** `allowanceAmount` was in the dependency array of `authenticate` (useCallback), which was in the dependency array of the auto-connect `useEffect`. Changing the input → new state → new callback ref → useEffect re-fires → calls `authenticate()`.
**Fix:** Added `allowanceAmountRef` (useRef) synced via a useEffect. `authenticate` now reads `allowanceAmountRef.current` instead of `allowanceAmount`, removing it from the callback dependency array.
**Files:** `ClearnodeProvider.tsx`, `ClearnodeProvider.test.tsx` (+1 test: changing allowance does not trigger re-auth)

### Bug 2: Fund Account shows `{"error":"amount must be a positive number"}`
**Root cause:** Stale `dist/` build had old faucet validation code. Source TypeScript was already correct.
**Fix:** Rebuilt with `pnpm --filter @pulse-play/hub build`. No code changes needed.

### Bug 3: Balance card not visible on Bettor page
**Root cause:** `AccountBalanceCard` only existed on `/account` page, not the bettor page.
**Fix:** Imported `AccountBalanceCard` into `app/page.tsx` and placed it above `PositionList` in the right sidebar.

### Test Results
- **Hub:** 212 passed (unchanged)
- **Frontend:** 182 passed (was 181, +1 new re-auth guard test)
- **Dashboard:** 33 passed (unchanged)
- **Total:** 427 passing tests

---

## Fix: qBall/qStrike not updating in dashboard MarketPanel
Date: 2026-02-05

### Root Cause
When a bet was placed, the hub broadcast `ODDS_UPDATE` containing only `priceBall`, `priceStrike`, and `marketId`. The updated `qBall`/`qStrike` values were not included. The dashboard's `ODDS_UPDATE` handler updated prices but never touched `state.market.qBall/qStrike`, so MarketPanel showed stale values (only initialized on `STATE_SYNC`). Same gap existed in the oracle market-open broadcast.

### Fix
Added `qBall` and `qStrike` fields to the `WsOddsUpdate` type and all broadcast sites.

### Files Changed

**Hub:**
- `api/types.ts` — Added `qBall`, `qStrike` to `WsOddsUpdate` interface
- `api/bet.routes.ts` — Include `qBall`, `qStrike` in ODDS_UPDATE broadcast after bet
- `api/oracle.routes.ts` — Include `qBall: market.qBall`, `qStrike: market.qStrike` in market-open ODDS_UPDATE broadcast
- `api/bet.routes.test.ts` — Added `qBall: expect.any(Number)`, `qStrike: expect.any(Number)` to ODDS_UPDATE assertion
- `api/oracle.routes.test.ts` — Added `qBall: 0`, `qStrike: 0` to market-open ODDS_UPDATE assertion

**Dashboard:**
- `types.ts` — Added `qBall`, `qStrike` to `WsOddsUpdate`
- `App.tsx` — ODDS_UPDATE handler now writes `qBall`/`qStrike` into `state.market`
- `utils/formatters.test.ts` — Added `qBall`, `qStrike` to ODDS_UPDATE test message literal

**Frontend:**
- `lib/types.ts` — Added `qBall`, `qStrike` to `WsOddsUpdate`
- `providers/MarketProvider.test.tsx` — Added `qBall`, `qStrike` to ODDS_UPDATE test message literal
- `providers/WebSocketProvider.test.tsx` — Added `qBall`, `qStrike` to ODDS_UPDATE test message literal

### Test Results
- **Hub:** 212 passed (unchanged count)
- **Frontend:** 182 passed (unchanged count)
- **Dashboard:** 33 passed (unchanged count)
- **Total:** 427 passing tests

---

## Fix: Dashboard MarketPanel crash on bet — `qBall.toFixed` undefined
Date: 2026-02-05

### Root Cause
The hub ran from compiled `dist/` (old build) while dashboard ran from TypeScript source (new code). The ODDS_UPDATE handler in `App.tsx` wrote `msg.qBall`/`msg.qStrike` into state unconditionally, but the stale `dist/` build didn't include those fields. Result: `undefined` overwrote valid values from STATE_SYNC, and `MarketPanel.tsx:57` crashed calling `.toFixed(2)` on `undefined`.

### Fixes
1. **Rebuilt hub** (`pnpm --filter @pulse-play/hub build`) — compiled `dist/` now includes `qBall`/`qStrike` in ODDS_UPDATE
2. **`dashboard/src/App.tsx`** — ODDS_UPDATE handler now guards setState with `msg.qBall !== undefined && msg.qStrike !== undefined`
3. **`dashboard/src/components/MarketPanel.tsx`** — Added `?? 0` fallback: `(market.qBall ?? 0).toFixed(2)` as defensive safety net

### Test Results
- **Dashboard:** 33 passed (unchanged)
- **Total:** 427 passing tests

---

## Fix: ClearnodeClient Drops Connection — Lazy Connect + Auto-Heal
Date: 2026-02-05

### Root Cause
The `ClearnodeClient` opened a WebSocket at server startup (`server.ts`) and never handled disconnection. When the Clearnode server dropped the connection (idle timeout, server restart, etc.), `isConnected()` returned `false` permanently — no recovery, no reconnect.

### Solution: Lazy Connect with Reuse
Replaced the upfront `connect()` at startup with an internal `ensureConnected()` before every RPC call. If the connection is live, reuse it (fast path). If it's dead or never opened, connect transparently. Deduplicates concurrent connect attempts via a shared promise.

### Files Changed

**`packages/hub/src/modules/clearnode/client.ts`**
- Added `private connectPromise: Promise<void> | null = null` field
- Added `private async ensureConnected()` method — checks `isConnected()` first, deduplicates via shared promise
- Replaced `this.assertConnected()` with `await this.ensureConnected()` in all 6 RPC methods (getBalance, submitAppState, closeSession, transfer, createAppSession, getAppSessions)
- Removed `private assertConnected()` method

**`packages/hub/src/server.ts`**
- Removed the post-startup `connect()` try/catch block (lines 43-50). Server starts instantly, client connects lazily on first API call.

**`packages/hub/src/logger.ts`**
- Added `clearnodeAutoConnect()` method

**`packages/hub/src/logger.test.ts`**
- Added `clearnodeAutoConnect` to both test blocks

**`packages/hub/src/modules/clearnode/client.test.ts`**
- Removed 6 "throws when not connected" tests (no longer applicable — methods auto-connect)
- Added 5 new tests in `describe("lazy connection")`:
  1. `auto-connects on first RPC call when not connected`
  2. `reuses existing connection on subsequent calls`
  3. `reconnects transparently when connection has dropped`
  4. `deduplicates concurrent connect attempts`
  5. `propagates connect failure to caller`

### Test Results
- **Hub:** 211 passed (was 212: -6 removed "not connected" tests, +5 new lazy connection tests)
- **Hub build:** ✅ clean (zero TypeScript errors)

### Behavioral Changes
- `connect()` / `disconnect()` / `isConnected()` remain public with same signatures
- Server starts without Clearnode dependency (faster startup)
- Connection self-heals on next RPC call after drop
- `GET /api/mm/info` calls `getBalance()` which now auto-connects, so the endpoint should almost always return `isConnected: true`
- No keepalive, no ping/pong, no reconnect timers needed

---

## Wire App Sessions into Betting Flow — Complete
Date: 2026-02-05

### Summary
Wired real Clearnode app sessions into three betting paths: bet placement (frontend), bet rejection (hub), and market resolution (hub). Previously, the frontend used a fake `appSessionId: session-${Date.now()}` and the hub never interacted with Clearnode during the bet lifecycle. Now:

1. **Frontend creates real app sessions** before notifying the hub via `useBet` hook
2. **Hub closes app sessions** when rejecting bets (returns user funds)
3. **Hub settles positions via Clearnode** at resolution (reallocates losers, pays winners)

### Steps Completed
1. **Unit conversion utility** — `toMicroUnits`/`fromMicroUnits` in both hub and frontend (Clearnode uses microunits: 1 USDC = 1,000,000)
2. **`appSessionVersion` field** — Added to Position, BetRequest, and all WS message types across hub, frontend, and dashboard
3. **`MM_ADDRESS` config** — Frontend reads from `NEXT_PUBLIC_MM_ADDRESS` env var
4. **`useBet` hook rewrite** — Creates real Clearnode app session → notifies hub with real session ID/version. Step tracking: `idle → creating-session → notifying-hub`
5. **Hub bet rejection** — Closes app session on market-state rejection to return user funds
6. **Hub resolution settlement** — Losers: `submitAppState` (reallocate to MM) + `closeSession`. Winners: `closeSession` (return costPaid) + `transfer` (profit). Losers processed first (MM needs funds).

### Files Created
- `packages/hub/src/utils/units.ts` — toMicroUnits, fromMicroUnits, MICRO, ASSET constants
- `packages/hub/src/utils/units.test.ts` — 8 tests
- `packages/frontend/src/lib/units.ts` — Same utility for frontend

### Files Modified
- `packages/hub/src/modules/position/types.ts` — Added `appSessionVersion: number`
- `packages/hub/src/api/types.ts` — Added `appSessionVersion` to BetRequest, WsPositionAdded, WsStateSync, PositionsResponse
- `packages/hub/src/api/bet.routes.ts` — Records appSessionVersion, closes session on rejection
- `packages/hub/src/api/oracle.routes.ts` — Full Clearnode settlement loop at resolution
- `packages/hub/src/api/positions.routes.ts` — Includes appSessionVersion in response
- `packages/hub/src/api/mm.routes.ts` — Fixed to check `isConnected()` and include in response
- `packages/hub/src/logger.ts` — 4 new log methods
- `packages/frontend/src/hooks/useBet.ts` — Rewritten for real app sessions
- `packages/frontend/src/components/bettor/BetForm.tsx` — Removed fake session ID, step-based loading
- `packages/frontend/src/lib/config.ts` — Added MM_ADDRESS
- `packages/frontend/src/lib/types.ts` — Added appSessionVersion
- `packages/dashboard/src/types.ts` — Added appSessionVersion
- All relevant test files updated across hub, frontend, dashboard

### Key Technical Details
- `AppSessionAllocation` uses `participant` field (NOT `destination`). `TransferParams` uses `destination`.
- `appSessionId` must be cast to `0x${string}` (Hex type) for Clearnode API calls
- Resolution processes losers before winners (MM needs loser funds to pay winner profit)
- Each position settlement wrapped in individual try/catch (continues on failure)
- `profit = payout (shares) - costPaid` — transfer only when profit > 0
- `jest.resetModules()` breaks React hooks (dual React instance) — used `globalThis` getter pattern for mutable config in tests

### Test Results
- **Hub:** 18 suites, 230 passed (6 skipped — pre-existing)
- **Frontend:** 24 suites, 185 passed
- **Dashboard:** 1 suite, 33 passed
- **Hub build:** ✅ clean
- **Frontend build:** ✅ clean

---

## Dashboard App Session Visibility
Date: 2026-02-05

### What was done:
Added session lifecycle tracking and visibility to the developer dashboard, giving developers a window into Yellow Network activity (Clearnode app sessions) alongside betting positions.

### Hub Changes:
1. **Position type** — Added `SessionStatus = 'open' | 'settling' | 'settled'` and `sessionStatus: SessionStatus` field to Position
2. **PositionTracker** — Added `updateSessionStatus(appSessionId, status)` method
3. **API types** — Added `WsSessionSettled` message type, `sessionCounts` to `AdminStateResponse`, `sessionStatus` to position shapes
4. **bet.routes.ts** — Sets `sessionStatus: 'open'` when recording positions
5. **oracle.routes.ts** — Calls `updateSessionStatus('settled')` + broadcasts `SESSION_SETTLED` after each loser/winner settlement (inside try/catch, only on success)
6. **admin.routes.ts** — Computes `sessionCounts: { open, settled }` from positions for admin state response
7. **app.ts** — STATE_SYNC includes `sessionCounts` for initial client sync

### Dashboard Changes:
1. **formatters.ts** — Added `getSessionStatusColor()` (open→green, settling→yellow, settled→blue), `SESSION_SETTLED` case in `formatWsMessage()`
2. **App.tsx** — Added `SESSION_SETTLED` handler (updates position status + decrements open/increments settled counts), `POSITION_ADDED` increments open count, adjusted `positionsVisibleCount` for 2-line layout
3. **PositionsPanel.tsx** — Two-line layout per position: Line 1 = bet info (address, outcome, shares, cost), Line 2 = session info (appSessionId, version, status with color)
4. **SystemInfo.tsx** — Added sessions row showing `open/settled` counts with green/blue color coding

### Frontend Changes:
- Mirrored type updates: `SessionStatus`, `sessionStatus` on Position, `WsSessionSettled`, `sessionCounts` on `AdminStateResponse`

### Files Modified:
- `hub/src/modules/position/types.ts` — SessionStatus + sessionStatus field
- `hub/src/modules/position/tracker.ts` — updateSessionStatus()
- `hub/src/modules/position/tracker.test.ts` — 3 new tests
- `hub/src/api/types.ts` — WsSessionSettled, sessionCounts, sessionStatus in shapes
- `hub/src/api/bet.routes.ts` — sessionStatus: 'open'
- `hub/src/api/oracle.routes.ts` — SESSION_SETTLED broadcast + updateSessionStatus
- `hub/src/api/admin.routes.ts` — sessionCounts computation
- `hub/src/api/positions.routes.ts` — sessionStatus in response mapping
- `hub/src/app.ts` — sessionCounts in STATE_SYNC
- `dashboard/src/types.ts` — Mirrored hub types
- `dashboard/src/utils/formatters.ts` — getSessionStatusColor, SESSION_SETTLED formatting
- `dashboard/src/utils/formatters.test.ts` — 6 new tests (4 sessionStatusColor + 1 SESSION_SETTLED + updated fixtures)
- `dashboard/src/App.tsx` — SESSION_SETTLED handler, layout calc, session count tracking
- `dashboard/src/components/PositionsPanel.tsx` — Two-line layout with session info
- `dashboard/src/components/SystemInfo.tsx` — Sessions row
- `frontend/src/lib/types.ts` — Type parity
- All hub test files updated with `sessionStatus: 'open'` in Position objects

### Test Results
- **Hub:** 18 suites, 233 passed (6 skipped — pre-existing)
- **Frontend:** 24 suites, 185 passed
- **Dashboard:** 1 suite, 38 passed
- **Hub build:** ✅ clean
- **Dashboard build:** ✅ clean
- **Frontend build:** ✅ clean

---

## Simulator Package Implementation
Date: 2026-02-05

### What was done:
Implemented `packages/simulator/` — a standalone Ink (React for terminal) app that generates wallets, funds them, controls the oracle, runs automated betting simulations, and displays everything in a fullscreen terminal UI for demo purposes.

### Package Structure:
```
packages/simulator/
├── package.json, tsconfig.json, jest.config.js
├── README.md, AGENTS.md
├── src/
│   ├── index.tsx                    — Entry point (CLI args, alt-screen, signals)
│   ├── App.tsx                      — Main Ink app (state, commands, layout)
│   ├── types.ts                     — Shared types (mirrors hub WsMessage + sim types)
│   ├── core/
│   │   ├── wallet-manager.ts        — Wallet generation + tracking (21 tests)
│   │   ├── hub-client.ts            — Hub REST client (15 tests)
│   │   ├── clearnode-pool.ts        — Per-wallet lazy Clearnode WS (14 tests)
│   │   ├── clearnode/auth.ts        — 3-step EIP-712 auth (adapted from hub)
│   │   ├── clearnode/rpc.ts         — sendAndWait helper (copied from hub)
│   │   └── simulation-engine.ts     — Bet orchestration (16 tests)
│   ├── hooks/
│   │   ├── useWebSocket.ts          — Adapted from dashboard
│   │   └── useTerminalSize.ts       — Copied from dashboard
│   ├── components/
│   │   ├── Header.tsx, WalletTable.tsx, MarketPanel.tsx, PriceBar.tsx
│   │   ├── EventLog.tsx, CommandBar.tsx, ResultsPanel.tsx, HelpOverlay.tsx
│   │   └── index.ts
│   ├── utils/
│   │   ├── formatters.ts            — Formatting helpers (36 tests)
│   │   └── units.ts                 — toMicroUnits/fromMicroUnits
│   └── test/mocks/
│       └── nitroliteModule.ts       — Jest mock for @erc7824/nitrolite
```

### Core Modules:
1. **WalletManager** — Generates private keys via viem, 1-based indexing, balance/funded tracking, profile assignment with ballBias
2. **HubClient** — REST wrapper for all hub endpoints: bet, faucet (user/mm), oracle (game-state/open/close/resolve), admin (state/positions/reset), mm/info
3. **ClearnodePool** — Per-wallet lazy Clearnode connections with EIP-712 auth, connection dedup via shared promise, createAppSession for betting
4. **SimulationEngine** — Staggered timer-based bet orchestration, resilient error handling, start/stop lifecycle, configurable SimConfig

### App Commands:
`:wallets <n>`, `:fund`, `:fund-mm [n]`, `:open`, `:close`, `:resolve ball|strike`,
`:sim start|stop|config`, `:status`, `:reset`, `:clear`, `:reconnect`, `:quit`

### Key Technical Details:
- Uses same 3-step EIP-712 auth flow as hub ClearnodeClient
- ClearnodePool deduplicates concurrent connect attempts via shared promise (same pattern as hub client.ts:238-245)
- SimulationEngine is resilient: errors don't stop the simulation, they emit events and schedule next bet
- WS message handling mirrors dashboard App.tsx patterns (STATE_SYNC, ODDS_UPDATE, MARKET_STATUS, etc.)
- Results computed on MARKET_STATUS RESOLVED by fetching positions and matching to simulator wallets

### Test Results:
- **Simulator:** 5 suites, 102 passed
  - wallet-manager: 21 tests
  - hub-client: 15 tests
  - clearnode-pool: 14 tests
  - simulation-engine: 16 tests
  - formatters: 36 tests
- **TypeScript:** ✅ clean (tsc --noEmit passes)

### Branch: feature/simulator

---

## Dashboard PositionsPanel → State Channels Table Redesign
Date: 2026-02-05

### What was done:
Redesigned the dashboard PositionsPanel from a plain two-line layout into a professional, session-first tabular layout branded as "⚡ STATE CHANNELS" for hackathon demo impact.

### Design Changes:
1. **Title**: `⚡ STATE CHANNELS (N)` in yellow+bold — Yellow Network branding
2. **Column headers**: SESSION | BETTOR | BET | ALLOC | v | STATUS — with gray bold text
3. **Separator line**: `─` repeated, gray dimColor
4. **Session ID first**: Yellow color, first column — state channels are the star
5. **Status badges**: Unicode indicators — `● OPEN` (green), `◌ SETTLING` (yellow), `◉ SETTLED` (blue)
6. **BET column**: Abbreviated `BALL`/`STRK` via `formatOutcomeShort()`
7. **ALLOC column**: `costPaid` (value locked in channel) — state channel terminology
8. **Version**: Compact `v1`/`v2` showing state channel updates
9. **Single-line per position**: Nearly doubles visible density vs. old two-line layout
10. **Empty state**: "Awaiting state channel activity..." instead of "No positions"
11. **Shares column dropped**: LMSR detail that distracts from state channel narrative

### Files Modified:
- `dashboard/src/utils/formatters.ts` — Added `formatStatusBadge()`, `formatOutcomeShort()`, `formatVersion()`
- `dashboard/src/utils/formatters.test.ts` — Added 9 tests (4 badge + 2 outcome + 3 version)
- `dashboard/src/components/PositionsPanel.tsx` — Full rewrite with tabular layout
- `dashboard/src/App.tsx` — Adjusted `positionsVisibleCount` from `Math.floor((rows-19)/2)` to `rows-21`

### Test Results:
- **Dashboard:** 1 suite, 47 passed
- **Dashboard build:** ✅ clean

---

## Simulator Bug Fixes: Balances, Layout, Speed
Date: 2026-02-06

### Bugs Fixed

**Bug 1: Balances don't update in real time**
- Root cause: `App.tsx` hardcoded `walletManager.updateBalance(w.index, '50000000')` after funding and never updated again
- Fix: Added `getBalance(address)` to `ClearnodePool` that fetches actual Clearnode ledger balance via `createGetLedgerBalancesMessage`/`parseGetLedgerBalancesResponse`
- Used in 3 places: after funding (`:fund`), after each bet (SimulationEngine), on `:status` command
- All balance fetches have fallback/silent-catch for resilience

**Bug 2: Event log cramped in 40% right column**
- Root cause: Layout was 60/40 side-by-side with EventLog behind MarketPanel+ResultsPanel in narrow right column
- Fix: Switched to top/bottom layout — WalletTable(55%)+MarketPanel(45%) side-by-side on top (~50% height), EventLog full-width on bottom (~50% height)

**Bug 3: Funding is slow (sequential)**
- Root cause: `:fund` command awaited each wallet fund sequentially
- Fix: Batched with `Promise.allSettled()`, 5 wallets per batch. UI updates after each batch. ~4x faster for 20 wallets.

### Files Changed
- `simulator/src/core/clearnode-pool.ts` — Added `getBalance()` method + nitrolite imports
- `simulator/src/core/clearnode-pool.test.ts` — +2 tests (getBalance success, asset not found)
- `simulator/src/core/simulation-engine.ts` — Balance refresh after successful bet
- `simulator/src/core/simulation-engine.test.ts` — +2 tests (balance refresh, graceful failure)
- `simulator/src/App.tsx` — Layout restructure + parallel funding + real balance fetch + `:status` balance refresh

### Test Results
- **Simulator:** 5 suites, 106 passed (was 102, +4 new)
- **TypeScript:** ✅ clean (tsc --noEmit passes)

---

## Dashboard Polish + Loser Session Status Bug Fix
Date: 2026-02-06

### Bug Fixed: Losers stay "open" after market resolution
**Root cause:** In `oracle.routes.ts`, `updateSessionStatus('settled')` and `SESSION_SETTLED` broadcast were INSIDE the try/catch block for Clearnode calls. If `submitAppState()` or `closeSession()` threw, the catch fired and the status update + broadcast were skipped. Meanwhile `BET_RESULT` was sent outside the try/catch, so the user saw "you lost" but the session stayed "open" on the dashboard.

**Fix:** Moved `updateSessionStatus`, `SESSION_SETTLED` broadcast, and `BET_RESULT` send OUTSIDE the try/catch for both losers AND winners. Now they always execute regardless of Clearnode call success. Updated the "continues resolution" test to verify SESSION_SETTLED is broadcast even when Clearnode fails.

### Dashboard UI Fixes
1. **Title renamed:** "⚡ STATE CHANNELS" → "⚡ APP SESSIONS" in PositionsPanel
2. **Dynamic separator width:** Added `panelWidth` prop to PositionsPanel, computed as `Math.floor(columns/2) - 4` in App.tsx, used for separator `'─'.repeat(panelWidth)` instead of hardcoded 54
3. **Border overlap fix:** Added `borderLeft={false}` to SystemInfo.tsx and EventLog.tsx outer Box — eliminates double-line where left column's right border meets right column's left border

### Pre-existing bug also fixed
- `mm.routes.test.ts` "disconnected" test was failing because it expected `isConnected()` gate in mm.routes.ts, but that was removed during the lazy-connect refactor. Updated test to match actual lazy-connect behavior (getBalance auto-connects).

### Files Modified
- `hub/src/api/oracle.routes.ts` — Status update + broadcasts moved outside try/catch for losers AND winners
- `hub/src/api/oracle.routes.test.ts` — Added SESSION_SETTLED assertion to Clearnode-failure test
- `hub/src/api/mm.routes.test.ts` — Fixed pre-existing test to match lazy-connect behavior
- `dashboard/src/components/PositionsPanel.tsx` — Renamed title, added panelWidth prop, dynamic separator
- `dashboard/src/App.tsx` — Computed + passed leftPanelWidth
- `dashboard/src/components/SystemInfo.tsx` — Added borderLeft={false}
- `dashboard/src/components/EventLog.tsx` — Added borderLeft={false}

### Test Results
- **Hub:** 18 suites, 233 passed (6 skipped)
- **Dashboard:** 1 suite, 47 passed
- **Hub build:** ✅ clean
- **Dashboard build:** ✅ clean

--- 2026-02-06: Dashboard WebSocket Message Queue Fix ---
- ROOT CAUSE FOUND: Dashboard was dropping WebSocket messages due to React state batching.
  When two WS messages arrived in the same event loop tick, setLastMessage() was called twice
  but React batched them, keeping only the last value. This caused loser SESSION_SETTLED
  messages to be silently dropped (winner's SESSION_SETTLED overwrote loser's).
- FIX: Replaced useState-based lastMessage in useWebSocket.ts with a ref-based message queue.
  Messages are pushed to messageQueueRef.current, and a queueVersion counter triggers re-renders.
  App.tsx drains the queue with splice(0) in useEffect, processing ALL messages in order.
- Also reverted borderLeft={false} on EventLog and SystemInfo panels (left borders restored).
- Files changed: useWebSocket.ts, App.tsx, SystemInfo.tsx, EventLog.tsx
- All 47 dashboard tests pass, TypeScript builds clean.

---

## Frontend: Auto-reconnect Clearnode WebSocket
Date: 2026-02-06

### Problem
Clearnode WebSocket server drops idle connections. Frontend had no recovery — `assertReady()` in
`methods.ts` just threw, making bets permanently fail until manual page refresh. Backend already
solved this with `ensureConnected()` lazy-connect pattern.

### Key Insight
ECDSA session signer survives WebSocket reconnections. If signer hasn't expired, only a new
WebSocket is needed — no re-authentication, no MetaMask popup. Full re-auth only when session
has actually expired.

### Solution: Two-tier auto-reconnect in ClearnodeProvider
1. **Detection**: Added `onclose`/`onerror` handlers on WebSocket after auth and after light reconnect.
   Status goes to 'disconnected' but signer/expiresAt are preserved (not nulled).
2. **Recovery**: `ensureConnected()` called before every method callback:
   - Signer valid + WS dead → `reconnectWsOnly()` (opens WS only, no MetaMask)
   - Signer expired/null → `authenticate()` (full 3-step auth, MetaMask popup)
   - Concurrent calls → deduplicated via `connectPromiseRef`
3. **Stale closure fix**: Method callbacks use `signerRef.current` (ref) instead of `signer` (state).
   Dependencies changed from `[signer, ...]` to `[ensureConnected, ...]`.

### Implementation Details
- Added 3 refs: `signerRef`, `expiresAtRef`, `connectPromiseRef`
- Refs synced everywhere state is set (auth success/failure, reconnect, disconnect, cleanup effect)
- `authenticate()` now re-throws errors (callers wrapped in try/catch where needed)
- `refreshBalance` uses refs but does NOT auto-reconnect (passive polling)
- `getConfig` (no signer needed) still calls `ensureConnected()` for WS readiness

### Files Modified
- `packages/frontend/src/providers/ClearnodeProvider.tsx` — Refs, reconnectWsOnly, ensureConnected,
  updated method callbacks, onclose/onerror handlers, authenticate re-throws
- `packages/frontend/src/providers/ClearnodeProvider.test.tsx` — 6 new tests

### New Tests
1. Light reconnects (WS only) when signer is still valid
2. Full re-auth when signer has expired
3. Deduplicates concurrent reconnection attempts
4. Status updates to disconnected when WS close event fires (signer preserved)
5. Method returns correct result after light reconnect
6. Error propagates when reconnection fails

### Test Results
- **Frontend:** 24 suites, 191 passed (was 185, +6 new)
- **No changes** to methods.ts, rpc.ts, auth.ts, types.ts, or useBet.ts

---

## Fix: Clearnode Connection Dropping + Winner Payout Missing
Date: 2026-02-06

### Bug 1: Connection keeps dropping (frontend)
**Root cause:** `useBet.ts` gated on `clearnodeStatus !== 'connected'` before calling `createAppSession`. When the Clearnode WS dropped (normal idle timeout), status went to `'disconnected'` and bets were rejected immediately — `createAppSession`'s built-in `ensureConnected()` (which handles transparent reconnection) was never reached.

**Fix:**
- Removed `clearnodeStatus` check (lines 52-57), destructure, and dependency from `useBet.ts`
- `createAppSession` already calls `ensureConnected()` internally which does light WS-only reconnect if signer is valid, or full re-auth if expired
- Replaced the "Clearnode not connected" test with a test verifying bets succeed via transparent reconnection when status is 'disconnected'

### Bug 2: Winner doesn't receive winnings from market maker
**Root cause (allowances):** `server.ts` created ClearnodeClient with `allowances: []`, overriding the default allowance in `auth.ts`. The MM's session key had no asset allowance, so `transfer()` (which sends profit from MM ledger to winner) failed silently.

**Root cause (error handling):** Winner settlement had `closeSession` and `transfer` in a single try/catch. When `transfer` failed, the error was caught but the user still saw "You Won!" (BET_RESULT sent outside try/catch). User got their bet back from `closeSession` but the profit from `transfer` was lost.

**Fixes:**
1. `server.ts` — Changed `allowances: []` to `allowances: [{ asset: 'ytest.usd', amount: '100000000000' }]` ($100k)
2. `oracle.routes.ts` — Separated winner `closeSession` and `transfer` into individual try/catch blocks with specific error labels (`resolution-winner-closeSession-*` and `resolution-winner-transfer-*`)
3. Added test: "winner gets BET_RESULT even when transfer fails" verifying error isolation and specific error logging

### Files Modified
- `packages/frontend/src/hooks/useBet.ts` — Removed `clearnodeStatus` gate
- `packages/frontend/src/hooks/useBet.test.ts` — Replaced "not connected" test with reconnection test
- `packages/hub/src/server.ts` — Added proper allowances to ClearnodeClient
- `packages/hub/src/api/oracle.routes.ts` — Separate try/catch for closeSession vs transfer
- `packages/hub/src/api/oracle.routes.test.ts` — Added partial settlement failure test

### Test Results
- **Hub:** 17 suites, 233 passed (+1 new oracle test), 1 pre-existing integration timeout (unrelated)
- **Frontend:** 24 suites, 191 passed (test count unchanged — replaced 1 test with 1 test)

---

## Fix: Clearnode WS Disconnect Leaking Into UI
Date: 2026-02-06

### Problem
When Clearnode WebSocket drops (normal idle timeout), `ClearnodeProvider` sets `status` to `'disconnected'`. UI components gated on `status === 'connected'` showed wrong states:
1. **AccountBalanceCard** showed "Connect wallet to view balance" despite having cached balance
2. **SessionCard** badge flipped to "Not Authenticated" despite valid signer
3. **refreshBalance** early-returned when WS dead (couldn't refresh)

### Fix 1: refreshBalance auto-reconnects
- Added `await ensureConnected()` at top of `refreshBalance` (wrapped in try/catch)
- Moved `refreshBalance` definition after `ensureConnected` to avoid reference-before-definition
- Dependency array changed from `[]` to `[ensureConnected]`

### Fix 2: AccountBalanceCard gates on balance not status
- Replaced `status === 'connected'` check with `balance === null`
- Balance is set after first auth, preserved on WS drop, only cleared on explicit disconnect
- Pulls `balance` + `refreshBalance` from context (dropped `status`)

### Fix 3: SessionCard decoupled from WS liveness
- `getStatusBadge()` now takes `expiresAt` as third parameter
- Priority: transitional states → error → `isSessionValid` (Active) → `expiresAt > 0 && !valid` (Expired) → fallthrough (Not Authenticated)
- Expiry section guard changed from `status === 'connected'` to `expiresAt > 0`

### Files Modified
- `packages/frontend/src/providers/ClearnodeProvider.tsx` — refreshBalance calls ensureConnected, moved after ensureConnected definition
- `packages/frontend/src/components/account/AccountBalanceCard.tsx` — Gate on `balance !== null` not `status`
- `packages/frontend/src/components/account/SessionCard.tsx` — Badge + expiry decoupled from WS status

### Tests Updated
- `ClearnodeProvider.test.tsx` — +2 tests (refreshBalance auto-reconnect, reconnect failure non-fatal)
- `AccountBalanceCard.test.tsx` — Updated "not-connected" to gate on `balance: null`, changed "null balance" to "zero balance", +1 test (disconnected with cached balance)
- `SessionCard.test.tsx` — +2 tests (Active when disconnected but valid, Expired badge when signer expires)

### Test Results
- **Frontend:** 24 suites, 196 passed (was 191, +5 new)

---

## Fix: "authentication required" After Clearnode WS Idle Disconnect
Date: 2026-02-06

### Root Cause
After a few minutes idle, the Clearnode server drops the WebSocket. `ensureConnected()` detected the dead WS and took a "light reconnect" path (`reconnectWsOnly()`), which opened a **raw, unauthenticated WebSocket** — it never sent the 3-step EIP-712 auth handshake. The Clearnode server binds auth state per-WebSocket, so it rejected the next RPC call with `{"error":"authentication required"}`.

### Fix: Two Changes

**1. WebSocket keepalive heartbeat**
- Added `useEffect` that sends `createGetConfigMessageV2()` (lightest RPC, no signer needed) every 30s while WS is OPEN
- Uses `wsRef` (ref) — no React state dependency, interval runs for provider lifetime
- Prevents the Clearnode server's idle timeout from ever triggering
- Send failures silently caught (non-fatal)

**2. Removed broken `reconnectWsOnly`, simplified `ensureConnected`**
- Deleted `reconnectWsOnly` — it opened a new WS without authentication, fundamentally broken
- Simplified `ensureConnected` to always call `authenticate()` when WS is dead (full 3-step handshake)
- This matches the hub's behavior where every reconnect does full auth
- Concurrent reconnection attempts still deduplicated via `connectPromiseRef`

### Files Modified
- `packages/frontend/src/providers/ClearnodeProvider.tsx` — Added `createGetConfigMessageV2` import, keepalive `useEffect`, deleted `reconnectWsOnly`, simplified `ensureConnected`
- `packages/frontend/src/providers/ClearnodeProvider.test.tsx` — Updated 4 reconnect tests (now verify full auth), added 1 keepalive test

### Test Updates
- Renamed "light reconnects (WS only)" → "reconnects with full auth when WS drops" — asserts `authenticateBrowser` called 2x
- Renamed "method returns correct result after light reconnect" → "after reconnect" — added auth mock
- Updated dedup test and refreshBalance reconnect test to include auth mocks
- Added "sends keepalive get_config message every 30 seconds" test using fake timers

### Test Results
- **Frontend:** 24 suites, 197 passed (was 196, +1 new keepalive test)

---

## Fix: Intermittent Faucet Funding Failures
Date: 2026-02-06

### Problem
When the simulator runs `:fund` for 10+ wallets, concurrent HTTP requests to the external sandbox faucet cause 503/500 errors. No retry logic and no concurrency control at any level.

### Solution: Three Layers

**Layer 1 — Retry with exponential backoff** (`faucet.ts`)
- Max 3 retries (4 total attempts)
- Backoff: 500ms base, doubling each retry, capped at 5s
- 0-20% random jitter to prevent thundering herd
- Retry on 5xx and network TypeError; throw immediately on 4xx
- `console.warn` for retries (suppressed in test via `NODE_ENV`)

**Layer 2 — Global request serialization queue** (`faucet.ts`)
- `requestFaucetQueued()` chains onto a module-level promise
- Only one HTTP request to external faucet in-flight at a time
- `_resetFaucetQueue()` exported for test cleanup
- Both `faucet.routes.ts` and `client.ts` switched to `requestFaucetQueued`

**Layer 3 — Reduced simulator concurrency** (`simulator/App.tsx`)
- `BATCH_SIZE` reduced from 5 to 2
- 1000ms inter-batch delay (skipped after last batch)

### Files Modified
- `packages/hub/src/modules/clearnode/faucet.ts` — Retry + queue implementation
- `packages/hub/src/modules/clearnode/faucet.test.ts` — **New** — 10 tests (7 retry + 3 queue)
- `packages/hub/src/api/faucet.routes.ts` — Import `requestFaucetQueued as requestFaucet`
- `packages/hub/src/api/faucet.routes.test.ts` — Mock exports `requestFaucetQueued`
- `packages/hub/src/modules/clearnode/client.ts` — Import + use `requestFaucetQueued`
- `packages/hub/src/modules/clearnode/client.test.ts` — Mock exports `requestFaucetQueued`
- `packages/simulator/src/App.tsx` — BATCH_SIZE=2, 1s inter-batch delay

### Test Results
- **Hub:** 19 suites, 244 passed (was 233, +10 new faucet tests, 1 suite skipped)
- **Simulator:** 5 suites, 106 passed (unchanged)
- **Total hub+sim:** 350 passing tests
