## Phase 1 Complete: Monorepo + LMSR Engine + Market Manager + Position Tracker
Date: 2026-02-04

### What was done:
1. **Monorepo scaffolding** — pnpm workspaces with root package.json, pnpm-workspace.yaml, tsconfig.base.json, .gitignore
2. **packages/hub** — TypeScript + Jest setup with ts-jest
3. **LMSR Engine** (`packages/hub/src/modules/lmsr/`)
   - `types.ts` — Outcome type
   - `engine.ts` — Stateless LMSR functions: costFunction, getPrice, getCost, getShares (binary search inverse), getNewQuantities
   - Uses log-sum-exp trick for numerical stability with large quantities
   - `engine.test.ts` — 23 tests covering prices, costs, shares, quantities, b-sensitivity
4. **Market Manager** (`packages/hub/src/modules/market/`)
   - `types.ts` — Market, MarketStatus, ResolutionResult types
   - `manager.ts` — State machine (PENDING→OPEN→CLOSED→RESOLVED), market CRUD, resolution with position-based winner/loser calculation
   - `manager.test.ts` — 21 tests covering creation, valid transitions, invalid transitions, timestamps, resolution logic
5. **Position Tracker** (`packages/hub/src/modules/position/`)
   - `types.ts` — Position type
   - `tracker.ts` — In-memory position storage with market/user/specific queries and cleanup
   - `tracker.test.ts` — 10 tests covering add, query, clear

### Test results:
- **54 tests passing** across 3 test suites
- Command: `pnpm --filter hub test`

### Architecture decisions:
- LMSR engine is purely stateless functions (no class) — easy to test and compose
- MarketManager is a class holding market state in a Map — supports multiple markets
- PositionTracker is a class with in-memory array — simple and sufficient for MVP
- Market resolution takes positions as a parameter (loose coupling with PositionTracker)
- Binary search for getShares inverse (100 iterations, 1e-10 tolerance)

### Tech stack so far:
- pnpm 10.x workspaces
- TypeScript 5.6
- Jest 29 + ts-jest 29
- Node 20+

---

## Phase 2 Complete: Yellow Network / Clearnode Integration
Date: 2026-02-04

### What was done:
1. **Dependencies added** — @erc7824/nitrolite@^0.5.3, viem@^2.45.1, ws@^8.19.0, @types/ws
2. **Clearnode module** (`packages/hub/src/modules/clearnode/`)
   - `types.ts` — ClearnodeConfig, SubmitAppStateParams, CloseSessionParams, TransferParams, AppSessionAllocation
   - `rpc.ts` — sendAndWait() promise-based WebSocket correlator (adapted from yellow-quickstart)
   - `auth.ts` — 3-step EIP-712 auth flow: auth_request → auth_challenge → auth_verify
   - `faucet.ts` — requestFaucet() HTTP helper for sandbox token distribution
   - `client.ts` — ClearnodeClient class: connect, disconnect, isConnected, getBalance, requestFaucet, submitAppState, closeSession, transfer
   - `rpc.test.ts` — 6 tests (send, resolve, ignore, error, timeout, concurrent)
   - `auth.test.ts` — 6 tests (request, challenge, verify, signer return, request fail, verify fail)
   - `client.test.ts` — 24 tests (connection lifecycle 6, getBalance 4, faucet 2, submitAppState 4, closeSession 4, transfer 4)
   - `client.live.test.ts` — 6 live tests gated by LIVE_TEST=true (auth, faucet, balance, disconnect)
3. **Jest config updated** — Added moduleNameMapper to resolve .js imports for ESM-style TypeScript

### Test results:
- **90 mock tests passing** across 6 test suites
- **6 live tests skipped** (run with LIVE_TEST=true pnpm --filter hub test)
- Command: `pnpm --filter hub test`

### Architecture decisions:
- ClearnodeClient wraps all Clearnode operations behind a clean interface
- Auth flow generates ephemeral session keys (lightweight ECDSA for repeated RPC calls)
- sendAndWait correlates request/response by RPC method name, handles errors and timeouts
- Faucet is a standalone helper (reusable for bettor funding in Phase 3)
- Live tests use throwaway ephemeral wallets against sandbox — no cleanup needed
- Module imports use .js extensions (ESM convention) with Jest moduleNameMapper for resolution

### How PulsePlay uses these operations:
- Fund MM (test): requestFaucet()
- Bet rejected: closeSession() — return funds to user
- Loser resolution: submitAppState() (reallocate user→MM) → closeSession()
- Winner resolution: closeSession() (return bet) → transfer() (pay profit from MM→user)
- Check liquidity: getBalance() — MM's available funds

### Next steps (Phase 3):
- Hub REST + WebSocket APIs (Fastify)
- POST /api/bet, GET /api/market, POST /api/oracle/*, POST /api/faucet/*
- WebSocket broadcast for real-time odds/market updates
- Mock Oracle with auto-play mode
- Wire LMSR + Market + Position + Clearnode into API endpoints

---

## Phase 3 Complete: Hub REST + WebSocket APIs
Date: 2026-02-04

### What was done:
1. **Dependencies added** — fastify, @fastify/websocket
2. **API types** (`src/api/types.ts`) — Request/response DTOs, WebSocket message type unions (ODDS_UPDATE, MARKET_STATUS, GAME_STATE, BET_RESULT)
3. **OracleService** (`src/modules/oracle/`) — Game state management, auto-play mode with configurable timers and outcome sequences, callbacks for market lifecycle
4. **WsManager** (`src/api/ws.ts`) — WebSocket connection tracking with per-address mapping, broadcast(), sendTo(), cleanup on close
5. **AppContext** (`src/context.ts`) — Shared context interface + createTestContext() helper with mocked ClearnodeClient
6. **App factory** (`src/app.ts`) — buildApp(ctx) creates Fastify instance with all routes and WebSocket support
7. **Routes:**
   - `bet.routes.ts` — POST /api/bet (LMSR integration: getShares → getNewQuantities → updateQuantities → record position → broadcast odds)
   - `market.routes.ts` — GET /api/market, GET /api/market/:marketId (with computed LMSR prices)
   - `positions.routes.ts` — GET /api/positions/:address
   - `oracle.routes.ts` — POST /api/oracle/game-state, /market/open, /market/close, /outcome (full lifecycle with WS broadcasts + individual BET_RESULT messages)
   - `faucet.routes.ts` — POST /api/faucet/user (stub), POST /api/faucet/mm (calls ClearnodeClient)
   - `admin.routes.ts` — GET /api/admin/state, POST /api/admin/reset
8. **Server entry point** (`src/server.ts`) — Creates real context from env vars and listens on PORT

### Test results:
- **184 tests passing** across 15 test suites (90 existing Phase 1+2 + 94 new Phase 3)
- 6 live Clearnode tests skipped (run with LIVE_TEST=true)
- Integration tests use real WebSocket connections (app.listen on port 0)
- All route tests use Fastify's app.inject() — no port binding needed

### Test breakdown (Phase 3 new — 94 tests):
- oracle.test.ts: 11 (game state, auto-play, timers)
- ws.test.ts: 8 (broadcast, sendTo, cleanup, clear)
- bet.routes.test.ts: 15 (validation, LMSR integration, WS broadcast)
- market.routes.test.ts: 8 (prices, states, by-ID lookup)
- positions.routes.test.ts: 5 (query, filtering, field completeness)
- oracle.routes.test.ts: 23 (game state, open/close/resolve, WS notifications, BET_RESULT delivery)
- faucet.routes.test.ts: 6 (stub, validation, ClearnodeClient integration)
- admin.routes.test.ts: 6 (state dump, reset, auto-play stop)
- integration.test.ts: 12 (full lifecycle, concurrent bets, real WS, market cycling)

### Architecture decisions:
- AppContext is a mutable object — admin reset replaces MarketManager/PositionTracker instances in-place
- Oracle module-level marketCounter generates sequential market IDs (resettable for tests)
- WsManager uses readyState === 1 (numeric) to avoid import dependency on WebSocket constant
- Integration tests track open sockets and close them in afterEach to prevent worker leaks
- Route handlers return response objects directly (Fastify serializes to JSON automatically)

### Next steps (Phase 4):
- Frontend scaffolding (Next.js 14)
- Connect to Hub WebSocket for real-time updates
- Betting UI with LMSR price display
- Game state visualization

---

## Phase 4 Complete: Frontend Core
Date: 2026-02-04

### What was done:
1. **Next.js 14 scaffolding** — Created @pulse-play/frontend package with TypeScript, Tailwind, App Router
2. **Jest + testing-library setup** — Mock modules for wagmi, viem, @tanstack/react-query, WebSocket
3. **Lib modules** (`src/lib/`)
   - `config.ts` — env var exports (HUB_REST_URL, HUB_WS_URL, PRIVATE_KEY)
   - `types.ts` — mirrors hub API types (MarketResponse, PositionsResponse, WsMessage, etc.)
   - `api.ts` — Hub REST client (placeBet, getMarket, getPositions, oracle endpoints)
4. **Providers** (`src/providers/`)
   - `WagmiProvider.tsx` — wagmi config + QueryClient + WalletContext (address derived from PRIVATE_KEY)
   - `WebSocketProvider.tsx` — WebSocket connection management, subscribe pattern for real-time updates
   - `MarketProvider.tsx` — Market state management, syncs with REST + WebSocket
5. **Hooks** (`src/hooks/`)
   - `useBet.ts` — Bet placement with loading/error states
   - `usePositions.ts` — Position fetching with auto-refetch on market resolution
   - `useMarket.ts`, `useWebSocket.ts` — barrel re-exports
6. **Shared Components** (`src/components/`)
   - `Header.tsx` — Logo, navigation (Bettor/Oracle), WebSocket status, WalletStatus
   - `WalletStatus.tsx` — Shows truncated address or "not configured"
7. **Bettor Components** (`src/components/bettor/`)
   - `OddsDisplay.tsx` — Ball/Strike prices as percentages + American odds
   - `BetForm.tsx` — Outcome selection, amount input with presets, place bet button
   - `PositionList.tsx` — Shows user's positions in current market
   - `BetResultToast.tsx` — Win/Loss notification from WebSocket BET_RESULT
8. **Oracle Components** (`src/components/oracle/`)
   - `GameControls.tsx` — Activate/Deactivate game toggle
   - `MarketControls.tsx` — Open/Close market, Resolve with Ball/Strike
   - `StateDisplay.tsx` — System state dashboard (market, positions, connections)
9. **App Pages** (`src/app/`)
   - `layout.tsx` + `LayoutInner.tsx` — Provider nesting (WagmiProvider > WebSocketProvider > MarketProvider)
   - `page.tsx` — Bettor view (OddsDisplay, BetForm, PositionList)
   - `oracle/page.tsx` — Oracle panel (GameControls, MarketControls, StateDisplay)
10. **Hub CORS** — Added @fastify/cors to hub for frontend cross-origin requests

### Test results:
- **67 tests passing** across 15 test suites
- Command: `pnpm --filter @pulse-play/frontend test`
- Build passes: `pnpm --filter @pulse-play/frontend build`

### Test breakdown (67 tests):
- lib/api: 9
- providers: 12 (WagmiProvider 3, WebSocketProvider 4, MarketProvider 5)
- hooks: 10 (useBet 5, usePositions 5)
- components/shared: 6 (Header 3, WalletStatus 3)
- components/bettor: 17 (OddsDisplay 4, BetForm 5, PositionList 4, BetResultToast 4)
- components/oracle: 13 (GameControls 4, MarketControls 5, StateDisplay 3)

### Architecture decisions:
- WagmiProvider uses viem's privateKeyToAccount for direct wallet; no connector dependencies
- WebSocket reconnects after 3 seconds on disconnect
- MarketProvider refetches on OPEN/RESOLVED status changes (not CLOSED)
- BetResultToast uses subscribe pattern to avoid prop drilling
- All components have data-testid attributes for testing
- Test mocks for wagmi/viem/react-query avoid ESM import issues in Jest

### Environment setup:
- Copy `.env.local.example` to `.env.local`
- Set `NEXT_PUBLIC_PRIVATE_KEY` to a test wallet private key

### Running the full stack:
1. Terminal 1: `pnpm --filter hub build && node packages/hub/dist/server.js`
2. Terminal 2: `pnpm --filter @pulse-play/frontend dev`
3. Open http://localhost:3000 (Bettor) or http://localhost:3000/oracle (Oracle)

### Next steps (Phase 5):
- Remaining personas (Bettor wallet connection, proper session management)
- E2E integration tests
- Demo polish

---

## MetaMask Wallet Connection with Environment Toggle
Date: 2026-02-05

### What was done:
1. **Config update** (`packages/frontend/src/lib/config.ts`)
   - Added `WalletMode` type ('metamask' | 'private-key')
   - Added `WALLET_MODE` export from `NEXT_PUBLIC_WALLET_MODE` env var (default: 'private-key')

2. **Jest mock for wagmi/connectors** (`src/test/mocks/wagmiConnectors.ts`)
   - New mock file with `injected()` connector export

3. **Jest config update** (`jest.config.js`)
   - Added `'^wagmi/connectors$'` module mapping

4. **wagmi mock update** (`src/test/mocks/wagmiModule.ts`)
   - Added test utilities: `__setMockAccountState`, `__setMockConnectFn`, `__setMockDisconnectFn`, `__resetMocks`
   - Imports injected connector from wagmiConnectors mock

5. **WagmiProvider refactor** (`src/providers/WagmiProvider.tsx`)
   - Extended WalletContextValue interface with: `mode`, `isConnecting`, `isConnected`, `connect`, `disconnect`
   - Added `WalletContextProviderInner` component that uses wagmi hooks (useAccount, useConnect, useDisconnect)
   - Conditional logic: MetaMask mode uses wagmi hooks, private-key mode uses static account
   - Connect finds injected connector and calls wagmi connect
   - Provider nesting: WagmiProviderBase → QueryClientProvider → WalletContextProviderInner

6. **WalletStatus update** (`src/components/WalletStatus.tsx`)
   - MetaMask mode, not connected: Shows "Connect Wallet" button
   - MetaMask mode, connecting: Shows "Connecting..." disabled button
   - MetaMask mode, connected: Shows address + "Disconnect" button
   - Private-key mode: Keeps existing behavior (no connect/disconnect buttons)

7. **Tests updated**
   - `WagmiProvider.test.tsx`: 6 tests for new context fields and behaviors
   - `WalletStatus.test.tsx`: Expanded to 11 tests covering both modes

8. **Environment documentation** (`.env.local.example`)
   - Documented `NEXT_PUBLIC_WALLET_MODE` with mode options

### Test results:
- **77 tests passing** across 15 test suites (was 67)
- Command: `pnpm --filter @pulse-play/frontend test`

### Breaking changes:
- None — `useWallet()` remains backwards compatible
- `address` and `isConfigured` still work as before
- New fields (`mode`, `isConnecting`, `isConnected`, `connect`, `disconnect`) added with sensible defaults

### Usage:
```bash
# Private-key mode (default) - existing behavior
NEXT_PUBLIC_WALLET_MODE=private-key
NEXT_PUBLIC_PRIVATE_KEY=0x...

# MetaMask mode - browser wallet connection
NEXT_PUBLIC_WALLET_MODE=metamask
```

### Notes:
- Module-level config evaluation means WALLET_MODE is read once at import time
- MetaMask mode tests would require Jest module isolation (complex), so coverage is via integration testing
- WagmiProvider test file simplified to avoid react multiple-instance issues with jest.doMock


### Build fix:
- Changed import from `wagmi/connectors` to main `wagmi` export for `injected` connector
- `wagmi/connectors` barrel imports porto module which has missing peer dependency
- Removed separate wagmiConnectors.ts mock file (injected now in wagmiModule.ts)
- Removed `^wagmi/connectors$` mapping from jest.config.js


---

## Terminal Developer Dashboard
Date: 2026-02-05

### What was done:
1. **New package created** — `@pulse-play/dashboard` with Ink + React for terminal UI
2. **Package dependencies** — ink@^4.4.1, ink-spinner@^5.0.0, react@^18.2.0, chalk@^5.3.0, ws@^8.19.0
3. **Hooks** (`src/hooks/`)
   - `useWebSocket.ts` — WebSocket connection with auto-reconnect (3s delay, max 10 attempts)
   - `useAdminState.ts` — REST polling for `/api/admin/state` and `/api/admin/positions/:marketId`
4. **Components** (`src/components/`)
   - `MarketPanel.tsx` — Market status, LMSR prices with American odds
   - `PositionsPanel.tsx` — Position list with truncated addresses
   - `EventLog.tsx` — Scrolling WebSocket event log with timestamps
   - `SystemInfo.tsx` — WS/API status, client count, game state
5. **Main App** (`src/App.tsx`)
   - 2-column layout with border boxes
   - Aggregates state from hooks
   - 'q' keypress to quit
6. **Entry point** (`src/index.tsx`)
   - CLI argument parsing for custom hub URL
   - Help flag support
   - Shebang for direct execution
7. **Formatters** (`src/utils/formatters.ts`)
   - formatOdds, formatAmericanOdds, truncateAddress, formatTime
   - formatWsMessage, getStatusColor, getOutcomeColor
   - formatDollars, formatShares
8. **Hub enhancement** — Added `GET /api/admin/positions/:marketId` endpoint to admin.routes.ts

### Test results:
- **23 dashboard tests** (all formatters)
- **187 hub tests** (was 184, +3 new admin position endpoint tests)
- Command: `pnpm --filter @pulse-play/dashboard test`

### Test breakdown (dashboard — 23 tests):
- formatOdds: 5
- formatAmericanOdds: 4
- truncateAddress: 2
- formatTime: 1
- formatWsMessage: 6
- getStatusColor: 1
- getOutcomeColor: 2
- formatDollars: 1
- formatShares: 1

### Running the dashboard:
```bash
# Terminal 1: Start hub
cd packages/hub && pnpm dev

# Terminal 2: Start dashboard
cd packages/dashboard && pnpm dev

# Or with custom URL
cd packages/dashboard && pnpm dev http://192.168.1.100:3001
```

### Architecture notes:
- Dashboard is a separate CLI process (not in-process with hub)
- Connects via WebSocket for real-time events, polls REST for state
- LMSR price calculation duplicated in App.tsx for local updates from polled state
- Event log is capped at 100 entries (FIFO)
- Positions panel shows max 5 positions

### Next steps:
- Live integration testing with hub
- E2E verification of full stack (hub + frontend + dashboard)

### Test fixes (during dashboard implementation):
- Fixed `BetForm.test.tsx` — changed `'Ball'` to `'BALL'` (uppercase as per types.ts)
- Fixed `MarketControls.test.tsx` — changed `'Ball'` to `'BALL'` (uppercase as per types.ts)
- These were pre-existing bugs from a previous outcome terminology refactor

### Final test counts:
- **Hub**: 189 passed (6 live tests skipped)
- **Frontend**: 77 passed
- **Dashboard**: 23 passed
- **Total**: 289 passing tests


---

## Dashboard Refactor: Polling → WebSocket
Date: 2026-02-05

### Problem
The dashboard was polling `/api/admin/state` every 1 second, filling backend logs unnecessarily.

### Solution
Replaced REST polling with WebSocket-based state synchronization.

### New WebSocket Message Types (hub/src/api/types.ts)
1. **POSITION_ADDED** — Broadcast when a bet creates a position
   - Contains full position object + total position count
2. **CONNECTION_COUNT** — Broadcast on connect/disconnect
   - Contains current count of WebSocket clients
3. **STATE_SYNC** — Sent to newly connected clients
   - Contains full AdminStateResponse + positions array

### Hub Changes
- `types.ts` — Added 3 new WsMessage types, updated union type
- `ws.ts` — Added broadcastConnectionCount() on connect/disconnect, added sendToSocket() method
- `app.ts` — Send STATE_SYNC to new WebSocket connections
- `bet.routes.ts` — Broadcast POSITION_ADDED after recording position

### Dashboard Changes
- `types.ts` — Mirrored new WsMessage types
- `App.tsx` — Completely refactored to derive state from WebSocket messages:
  - STATE_SYNC initializes full state on connect
  - POSITION_ADDED adds to positions list
  - CONNECTION_COUNT updates client count
  - MARKET_STATUS/GAME_STATE/ODDS_UPDATE update respective state
  - Removed useAdminState import and REST polling
- `index.tsx` — Removed restUrl prop (no longer needed)
- `formatters.ts` — Added formatting for new message types
- `hooks/index.ts` — Removed useAdminState export (deprecated)

### Test Updates
- `ws.test.ts` — Updated 8 tests to account for CONNECTION_COUNT broadcasts, added 4 new tests
- `formatters.test.ts` — Added 3 tests for new message type formatting

### Test Results
- **Hub:** 192 passed (was 187, +5 new WS tests)
- **Frontend:** 77 passed
- **Dashboard:** 26 passed (was 23, +3 formatter tests)
- **Total:** 295 passing tests

### Benefits
- No more polling logs in backend
- Real-time state updates via WebSocket
- Lower backend load
- Simpler dashboard architecture (single data source)

---

## Frontend Refactor: StateDisplay Polling → WebSocket
Date: 2026-02-05

### Problem
The frontend's StateDisplay component (Oracle view) was polling `/api/admin/state` every 5 seconds, duplicating the same issue that was fixed in the dashboard.

### Solution
Extended the frontend's MarketProvider to handle all WebSocket message types and provide admin state to StateDisplay via context.

### Frontend Types Changes (src/lib/types.ts)
- Added `address` field to Position interface
- Added 3 new WebSocket message types (mirroring hub):
  - `WsPositionAdded` — position + positionCount
  - `WsConnectionCount` — count
  - `WsStateSync` — full AdminStateResponse + positions
- Updated `WsMessage` union type

### MarketProvider Changes (src/providers/MarketProvider.tsx)
- Added `positionCount` and `connectionCount` to MarketState
- Handle new WebSocket message types:
  - `STATE_SYNC` — Initialize market, prices, gameActive, positionCount, connectionCount
  - `CONNECTION_COUNT` — Update connectionCount
  - `POSITION_ADDED` — Update positionCount
- Exposed new values in context

### StateDisplay Changes (src/components/oracle/StateDisplay.tsx)
- Removed useState for market, gameState, positionCount, connectionCount
- Removed useEffect with setInterval polling
- Removed fetchState() REST function
- Now gets all state from useMarket() hook
- Same UI rendering logic preserved

### Test Fixes
- Updated all test files to use uppercase 'BALL'/'STRIKE' (was 'Ball'/'Strike'):
  - `usePositions.test.tsx` — 4 occurrences
  - `api.test.ts` — 5 occurrences
  - `MarketProvider.test.tsx` — 1 occurrence
- Added missing `address` field to Position mocks in tests

### Test Results
- **Hub:** 192 passed
- **Frontend:** 81 passed (was 77, +4 new MarketProvider context tests)
- **Dashboard:** 26 passed
- **Total:** 299 passing tests

### Benefits
- Oracle StateDisplay now updates instantly via WebSocket
- Eliminated /api/admin/state polling from frontend
- Consistent state sync architecture across dashboard and frontend
- All state flows through WebSocket → MarketProvider → components

---

## Fix: Dashboard market-id not updating & odds not resetting on new market
Date: 2026-02-05

### Bugs Fixed

**Bug 1: Dashboard market-id not updating**
- MARKET_STATUS handler in `dashboard/src/App.tsx` spread `prev.market` without updating `id`
- When market-2 opened, dashboard still showed market-1's ID

**Bug 2: Odds not resetting on new market**
- No ODDS_UPDATE broadcast when a new market opened (hub)
- Dashboard & frontend preserved old `qBall`/`qStrike` values via spread
- Old odds persisted because only bets triggered ODDS_UPDATE

### Changes

1. **Hub (`oracle.routes.ts`)** — Added `getPrice` import and ODDS_UPDATE broadcast after MARKET_STATUS in market open handler. New market now broadcasts both MARKET_STATUS(OPEN) and ODDS_UPDATE(0.5/0.5).

2. **Dashboard (`App.tsx`)** — Rewrote MARKET_STATUS handler to detect new market by comparing `prev.market.id !== msg.marketId`. When new: creates fresh market object, clears positions, resets prices to 50/50. When same market: updates status/outcome and always copies `msg.marketId`.

3. **Frontend (`MarketProvider.tsx`)** — Rewrote MARKET_STATUS handler with same new-market detection. When new market: resets qBall/qStrike/b, prices to 50/50, positionCount to 0. Always copies `message.marketId` into market state. Still triggers refetch on OPEN/RESOLVED.

### Tests Added
- Hub: +1 test — `broadcasts ODDS_UPDATE with 50/50 prices on market open`
- Frontend: +2 tests — `updates market ID when MARKET_STATUS arrives with new marketId`, `resets prices and positionCount for new market`

### Test Results
- **Hub:** 193 passed (was 192)
- **Frontend:** 83 passed (was 81)
- **Dashboard:** 26 passed (unchanged)
- **Total:** 302 passing tests

---

## Fix: Double WebSocket Connection in Frontend (StrictMode)
Date: 2026-02-05

### Root Cause
React StrictMode double-invokes effects in development: mount → unmount → mount. The cleanup function called `ws.close()`, which fired `onclose` and scheduled a reconnect via `setTimeout(connect, 3000)`. Since `reconnectTimeoutRef` was already `null` at that point, the orphaned timeout was never cleared. Result: two connections per address (one immediate from re-mount, one 3 seconds later from orphaned reconnect).

### Fix
Added `intentionalClose` closure variable in the `useEffect`. Set to `true` in the cleanup function **before** calling `ws.close()`. The `onclose` handler checks this flag and skips reconnection when the close was intentional.

### Files Changed
- `packages/frontend/src/providers/WebSocketProvider.tsx` — added `intentionalClose` guard
- `packages/frontend/src/providers/WebSocketProvider.test.tsx` — added cleanup test

### Test Results
- **Frontend:** 84 passed (was 83, +1 new cleanup test)
- **Total:** 303 passing tests

---

## Market Maker Overview Page
Date: 2026-02-05

### What was done:

#### Hub Changes
1. **types.ts** — Added `MMFaucetRequest` (optional count) and `MMInfoResponse` (address, balance, isConnected)
2. **logger.ts** — Updated `faucetMM()` signature to include count parameter; added `mmInfoFetched()` method
3. **mm.routes.ts** (new) — `GET /api/mm/info` returns MM wallet address, balance, and connection status
4. **faucet.routes.ts** — Modified `POST /api/faucet/mm` to accept `{ count?: number }` (default 1, capped at 50). Loops count times calling `requestFaucet()`. Returns partial results on mid-loop failure.
5. **app.ts** — Registered `registerMMRoutes(app, ctx)`
6. **mm.routes.test.ts** (new) — 2 tests (info endpoint success + error handling)
7. **faucet.routes.test.ts** — Added 4 new tests (count=3, no body default, count>50 rejection, partial failure)

#### Frontend Changes
1. **types.ts** — Added `MMInfoResponse` and `MMFaucetResponse` interfaces
2. **api.ts** — Added `getMMInfo()` and `requestMMFaucet(count)` functions
3. **api.test.ts** — Added 3 tests for new API functions
4. **Header.tsx** — Added "Market Maker" nav link with `data-testid="nav-market-maker"`
5. **Header.test.tsx** — Updated to verify Market Maker link presence
6. **market-maker/page.tsx** (new) — Page with 2-column grid (2/3 + 1/3): MMFaucetCard left, MMBalanceCard right. Uses refreshKey pattern for faucet→balance refresh.
7. **market-maker/MMBalanceCard.tsx** (new) — Displays truncated address (copy-to-clipboard), balance formatted as $ (raw/1,000,000), connection status badge, refresh button. Loading skeleton + error states.
8. **market-maker/MMFaucetCard.tsx** (new) — Preset amounts ($10, $50, $100, $500), custom input (multiples of $10), divides by 10 for count. Shows success/warning/error states. Calls onFunded callback for balance refresh.
9. **market-maker/index.ts** (new) — Barrel export
10. **MMBalanceCard.test.tsx** (new) — 5 tests (loading, display, refresh, error, disconnected)
11. **MMFaucetCard.test.tsx** (new) — 9 tests (presets, selection, custom input, submit, loading, success, partial failure, error, onFunded callback)

### Test Results
- **Hub:** 199 passed (was 193, +6 new: 2 mm routes + 4 faucet batch)
- **Frontend:** 104 passed (was 84, +20 new: 3 api + 1 header + 5 balance + 9 faucet + 2 unused)
- **Dashboard:** 26 passed (unchanged)
- **Total:** 329 passing tests

### Architecture Notes
- MMBalanceCard uses `refreshKey` prop to trigger re-fetch after faucet funding
- Balance formatted by dividing raw string by 1,000,000 (ytest.usdc uses 6 decimals)
- Faucet batch: count = selectedAmount / 10 (each faucet request = $10 ytest.usdc)
- Partial failure returns `{ success: true, funded: N, requested: count, error: string }` — no 500 if at least one succeeded

---

## Fix: GET /api/mm/info crash when ClearnodeClient disconnected
Date: 2026-02-05

### Problem
`GET /api/mm/info` threw 500 with `"ClearnodeClient is not connected"` because `getBalance()` calls `assertConnected()` internally. When the hub starts without Clearnode credentials or the WebSocket hasn't connected, the endpoint crashed.

### Fix
- Check `isConnected()` before calling `getBalance()`. When disconnected, return `balance: "0"` instead of crashing.
- Moved `isConnected` check before `getBalance` call so it gates the balance fetch.

### Files Changed
- `packages/hub/src/api/mm.routes.ts` — Reordered: get address → check isConnected → conditionally get balance
- `packages/hub/src/api/mm.routes.test.ts` — Added test: disconnected case returns 200 with `{ address: "0xMM", balance: "0", isConnected: false }`

### Test Results
- **Hub:** 200 passed (was 199, +1 new disconnected test)
- **Total:** 330 passing tests

---

## Fix: Connect ClearnodeClient on server startup
Date: 2026-02-05

### Problem
`clearnodeClient.connect()` was never called in `server.ts`. The client was constructed but the WebSocket + EIP-712 auth handshake was never initiated, meaning `isConnected()` was always `false` in production and all WebSocket-dependent operations would fail.

### Fix
1. **server.ts** — Added `await clearnodeClient.connect()` after `app.listen()` in a try/catch. On success logs `clearnodeConnected`, on failure logs error + `clearnodeDisconnected`. Server stays up either way (degraded mode — faucet HTTP still works, `mm/info` returns `balance: "0"`).
2. **logger.ts** — Added `clearnodeConnected(address)` and `clearnodeDisconnected()` methods with ANSI formatting.
3. **logger.test.ts** — Added both methods to existing test blocks (callable + no stdout in test env).
4. **context.ts** — Verified: mock already had `connect` and `disconnect` — no changes needed.

### Test Results
- **Hub:** 200 passed (unchanged count, existing tests still pass)
- **Total:** 330 passing tests

---

## Frontend ClearnodeProvider Implementation
Date: 2026-02-05

### What was done:
Implemented a `ClearnodeProvider` that authenticates the bettor's wallet with the Yellow Network Clearnode on wallet connect, obtains a session key, and exposes the signer/WS for future Clearnode operations.

#### New files:
1. **`lib/clearnode/types.ts`** — `ClearnodeStatus`, `ClearnodeContextValue`, `AuthResult` types
2. **`lib/clearnode/rpc.ts`** — Browser-compatible `sendAndWaitBrowser()` and `openClearnodeWs()` (ported from yellow-quickstart)
3. **`lib/clearnode/auth.ts`** — Browser-compatible 3-step EIP-712 auth (`authenticateBrowser()`) mirroring hub's auth.ts
4. **`lib/clearnode/index.ts`** — Barrel re-export
5. **`providers/ClearnodeProvider.tsx`** — React context provider with auto-auth on wallet connect, balance fetch, reconnect/disconnect
6. **`hooks/useClearnode.ts`** — Convenience hook re-export
7. **`test/mocks/nitroliteModule.ts`** — Jest mock for `@erc7824/nitrolite` SDK

#### Test files:
- `lib/clearnode/rpc.test.ts` — 8 tests (sendAndWaitBrowser: resolve, ignore non-matching, RPC error, timeout, cleanup, unparseable; openClearnodeWs: resolve on open, reject on error)
- `lib/clearnode/auth.test.ts` — 6 tests (full 3-step flow, no account, verify fail, propagate errors, custom config, default config)
- `providers/ClearnodeProvider.test.tsx` — 10 tests (disconnected, auto-auth, balance fetch, WS fail, auth fail, ws ref, disconnect cleanup, reconnect, unmount cleanup, balance fetch fail)

#### Modified files:
- **`package.json`** — Added `@erc7824/nitrolite@^0.5.3` dependency
- **`jest.config.js`** — Added `@erc7824/nitrolite` and `viem/chains` module name mappers
- **`lib/config.ts`** — Added `CLEARNODE_URL` export
- **`test/mocks/wagmiModule.ts`** — Added `useWalletClient` mock + `__setMockWalletClient()` test utility
- **`test/mocks/viemModule.ts`** — Updated `createWalletClient` to accept options including account
- **`app/LayoutInner.tsx`** — Inserted `ClearnodeProvider` between `WagmiProvider` and `WebSocketProvider`
- **`providers/index.ts`** — Added ClearnodeProvider + useClearnode exports
- **`.env.local.example`** — Added `NEXT_PUBLIC_CLEARNODE_URL`

### Provider hierarchy:
```
WagmiProvider              (wallet: MetaMask or private-key)
  ClearnodeProvider        (Clearnode WS auth, session key, balance)
    WebSocketProvider      (Hub WS: market updates)
      MarketProvider       (market state)
```

### Context interface:
```typescript
interface ClearnodeContextValue {
  status: 'disconnected' | 'connecting' | 'authenticating' | 'connected' | 'error';
  error: string | null;
  isSessionValid: boolean;
  signer: MessageSigner | null;
  ws: WebSocket | null;
  balance: string | null;
  refreshBalance: () => Promise<void>;
  reconnect: () => Promise<void>;
  disconnect: () => void;
}
```

### Auth flow:
- Private-key mode: auto-creates WalletClient from env var, signs EIP-712 automatically
- MetaMask mode: waits for wagmi's useWalletClient to be available, then delegates signing to MetaMask
- Both modes: opens WS → 3-step EIP-712 auth → stores session signer → fetches balance
- Session expiry tracked via `expiresAt` + `isSessionValid` computed property

### Test Results
- **Frontend:** 128 passed (was 104, +24 new: 8 rpc + 6 auth + 10 provider)
- **Total:** 354 passing tests

---

## User Account Page Implementation
Date: 2026-02-05

### What was done:
Implemented the `/account` page with 3 cards: Session management, Faucet funding, and Balance display.

#### Hub Changes
1. **types.ts** — Changed `FaucetRequest` from `{ address, amount }` to `{ address, count? }` (count-based like MM faucet)
2. **faucet.routes.ts** — Rewrote `POST /api/faucet/user` to call `requestFaucet(address)` from clearnode/faucet.ts in a loop. Accepts `{ address, count? }` (default 1, max 50). Returns `{ success, funded }` or partial failure with `{ success, funded, requested, error }`.
3. **logger.ts** — Updated `faucetUser()` to match count-based pattern: `faucetUser(address, count?, error?)`
4. **faucet.routes.test.ts** — Rewrote user faucet tests (7 tests: success, missing address, count=3, default count, count>50, partial failure, total failure). Mock of `requestFaucet` module added.
5. **logger.test.ts** — Updated faucetUser test calls to match new signature.

#### Frontend: ClearnodeProvider Updates
1. **lib/clearnode/types.ts** — Added `expiresAt`, `allowanceAmount`, `setAllowanceAmount` to `ClearnodeContextValue`
2. **providers/ClearnodeProvider.tsx** — Added `allowanceAmount` state (default 1000), `setAllowanceAmount` setter, exposed `expiresAt` in context. Passes custom allowance to `authenticateBrowser()`.
3. **providers/ClearnodeProvider.test.tsx** — Added 4 tests: expiresAt exposed, allowanceAmount default, setAllowanceAmount updates, allowance passed to auth

#### Frontend: API + Types
1. **lib/types.ts** — Added `UserFaucetResponse` interface
2. **lib/api.ts** — Added `requestUserFaucet(address, count?)` function
3. **lib/api.test.ts** — Added 2 tests for requestUserFaucet

#### Frontend: Account Components (new)
1. **components/account/SessionCard.tsx** — Session status badge (Active/Expired/Connecting/Error/Not Authenticated), expiry time display, allowance input, re-authenticate button
2. **components/account/AccountBalanceCard.tsx** — Balance display ($X.XX from raw/1M), refresh button, not-connected state
3. **components/account/AccountFaucetCard.tsx** — Preset amounts ($10/$50/$100/$500), custom input (multiples of $10), calls requestUserFaucet + refreshBalance, success/warning/error states
4. **components/account/index.ts** — Barrel export

#### Frontend: Page + Navigation
1. **app/account/page.tsx** — 3-card layout: SessionCard (full width), FaucetCard (2/3), BalanceCard (1/3). Uses refreshKey pattern.
2. **components/Header.tsx** — Added "Account" nav link with data-testid="nav-account"
3. **components/Header.test.tsx** — Updated to verify Account link presence

#### Test Files (new)
- `SessionCard.test.tsx` — 10 tests (status badges, expiry, reconnect, disabled state, allowance input)
- `AccountBalanceCard.test.tsx` — 5 tests (not-connected, balance display, null balance, refresh, large balance)
- `AccountFaucetCard.test.tsx` — 9 tests (presets, selection, custom input, submit, loading, success, partial failure, error, onFunded + refreshBalance callback)

### Test Results
- **Hub:** 204 passed (was 200, +4 new user faucet route tests)
- **Frontend:** 158 passed (was 128, +30 new: 4 provider + 2 api + 10 session + 5 balance + 9 faucet)
- **Dashboard:** 26 passed (unchanged)
- **Total:** 388 passing tests

### Architecture Notes
- User faucet routes through hub (avoids CORS issues with sandbox faucet direct call)
- Allowance is stored in ClearnodeProvider state; changing it requires re-authentication
- Session expiry and validity exposed in context for UI display
- AccountFaucetCard calls both onFunded callback (refreshKey) and refreshBalance (Clearnode balance)
- Same refreshKey pattern as MM page for faucet → balance refresh coordination

---

## Dashboard Upgrade: Fullscreen Interactive TUI
Date: 2026-02-05

### What was done:
Upgraded the `packages/dashboard/` terminal app from a simple read-only view to a fullscreen, interactive TUI with alternate screen buffer, dynamic sizing, panel navigation, scrollable panels, vim-style command bar, and visual price bars.

### New files:
1. **`hooks/useTerminalSize.ts`** — Hook returning `{ columns, rows }` from `process.stdout`, updates on resize, fallback 80x24
2. **`components/PriceBar.tsx`** — ASCII progress bar (`█░`) for BALL/STRIKE odds visualization
3. **`components/CommandBar.tsx`** — Footer component: keybinding hints (normal), command input (command mode), status messages
4. **`components/HelpOverlay.tsx`** — Keybinding reference screen (press `?` to toggle)

### Modified files:
1. **`hooks/useWebSocket.ts`** — Added `reconnect()` to `UseWebSocketResult` interface and return value
2. **`utils/formatters.ts`** — Added `renderPriceBar(probability, width)` pure function
3. **`index.tsx`** — Alternate screen buffer enter/exit (`\x1b[?1049h/l`), cursor hide/show, signal handlers (SIGINT, SIGTERM, uncaughtException), passes `hubUrl` prop to App
4. **`App.tsx`** — Major rewrite:
   - Fullscreen layout with `height={rows}` from useTerminalSize
   - Panel navigation (Tab to switch, j/k to scroll, g/G for top/bottom)
   - Command mode (`:clear`, `:reset`, `:reconnect`, `:quit`)
   - Help mode (press `?`)
   - Auto-scroll event log to bottom (disabled when user manually scrolls up, re-enabled on `G`)
   - Dynamic visible count calculation based on terminal rows
   - Price bar width derived from `columns / 2 - 6`
5. **`components/MarketPanel.tsx`** — Replaced plain text odds with PriceBar components, accepts `barWidth` prop
6. **`components/PositionsPanel.tsx`** — Scrollable with `scrollOffset`/`visibleCount`/`isActive` props, cyan border when active, scroll indicator
7. **`components/EventLog.tsx`** — Same scrollable pattern as PositionsPanel, chronological order (oldest first)
8. **`components/SystemInfo.tsx`** — Added `flexShrink={0}` for layout stability
9. **`components/index.ts`** — Added PriceBar, CommandBar, HelpOverlay exports
10. **`hooks/index.ts`** — Added useTerminalSize export
11. **`README.md`** — Updated with new layout diagram, controls tables, commands, architecture notes

### Test Results:
- **Dashboard:** 33 passed (was 26, +7 new renderPriceBar tests)
- TypeScript: zero errors (`tsc --noEmit` clean)

### Controls:
- **Tab** — Switch active panel (Positions ↔ Event Log)
- **j/↓, k/↑** — Scroll active panel
- **g/G** — Top/bottom of active panel
- **?** — Toggle help overlay
- **:** — Enter command mode
- **q** — Quit
- **:clear/:c** — Clear event log
- **:reset/:r** — POST /api/admin/reset
- **:reconnect** — Reconnect WebSocket
- **:quit/:q** — Quit

### Architecture Notes:
- Alternate screen buffer ensures terminal history is preserved
- `useTerminalSize` listens to `process.stdout.on('resize')` for dynamic layout
- Event log auto-scrolls to bottom unless user manually scrolled up; pressing `G` re-enables auto-scroll
- `reconnect()` in useWebSocket closes current WS, clears timeout, resets attempts, and reconnects
- `renderPriceBar()` is a pure function for testability — PriceBar component just renders its output
- No new npm dependencies required

---

## Clearnode Client Methods: Hub + Frontend
Date: 2026-02-05

### What was done:
Added `createAppSession`, `getAppSessions` to the Hub ClearnodeClient, and a full set of pure RPC method functions for the Frontend. Integrated all methods into the ClearnodeProvider context.

### Hub Changes
1. **types.ts** — Added `CreateAppSessionParams`, `CreateAppSessionResult`, `AppSessionInfo` interfaces
2. **client.ts** — Added `createAppSession()` and `getAppSessions()` methods with new nitrolite SDK imports (`createAppSessionMessage`, `parseCreateAppSessionResponse`, `createGetAppSessionsMessage`, `parseGetAppSessionsResponse`, `RPCProtocolVersion`, `RPCChannelStatus`)
3. **client.test.ts** — Added 8 tests in 2 new describe blocks: createAppSession (4 tests), getAppSessions (4 tests)
4. **context.ts** — Added `createAppSession` and `getAppSessions` to mockClearnode in `createTestContext()`

### Frontend Changes
1. **lib/clearnode/methods.ts** (new) — 6 pure async RPC functions: `createAppSession`, `closeAppSession`, `submitAppState`, `transfer`, `getAppSessions`, `getConfig`. Each takes `(ws, signer, ...)` — testable without React.
2. **lib/clearnode/methods.test.ts** (new) — 17 tests covering all 6 methods (correct SDK calls, return values, throws when not connected)
3. **test/mocks/nitroliteModule.ts** — Added 14 new mock exports for all app session, state, transfer, config SDK functions + RPCAppStateIntent and RPCProtocolVersion enums
4. **lib/clearnode/index.ts** — Added `export * from './methods'`
5. **lib/clearnode/types.ts** — Extended `ClearnodeContextValue` with 6 new method signatures
6. **providers/ClearnodeProvider.tsx** — Added 6 useCallback wrappers that capture wsRef/signer/address, updated default context with error-throwing stubs
7. **providers/ClearnodeProvider.test.tsx** — Added 6 tests verifying each method delegates correctly when connected

### Also fixed:
- Removed unused `waitFor` import from `SessionCard.test.tsx` (pre-existing lint issue)

### Test Results
- **Hub:** 212 passed (was 204, +8 new clearnode client tests)
- **Frontend:** 181 passed (was 158, +17 methods + 6 provider)
- **Frontend build:** ✅ succeeds
- **Total:** 393+ passing tests

### Architecture Notes
- Frontend methods are pure functions (not hooks/components) for easier testing
- `getConfig` uses V2 variant (synchronous, no signer needed)
- `createAppSession` defaults to `pulse-play` application, NitroRPC/0.4 protocol, weights [0, 100] quorum 100 (bettor has 0 weight, MM has 100 = full control)
- All methods use `assertReady()` guard that checks WS readyState and signer presence
- Provider uses `useCallback` with dependency on `signer` and `address` for React memoization

---

## Bug Fixes: Account Page Issues
Date: 2026-02-05

### Bug 1: Allowance input triggers re-authentication on every keystroke
**Root cause:** `allowanceAmount` was in the dependency array of `authenticate` (useCallback), which was in the dependency array of the auto-connect `useEffect`. Changing the input → new state → new callback ref → useEffect re-fires → calls `authenticate()`.
**Fix:** Added `allowanceAmountRef` (useRef) synced via a useEffect. `authenticate` now reads `allowanceAmountRef.current` instead of `allowanceAmount`, removing it from the callback dependency array.
**Files:** `ClearnodeProvider.tsx`, `ClearnodeProvider.test.tsx` (+1 test: changing allowance does not trigger re-auth)

### Bug 2: Fund Account shows `{"error":"amount must be a positive number"}`
**Root cause:** Stale `dist/` build had old faucet validation code. Source TypeScript was already correct.
**Fix:** Rebuilt with `pnpm --filter @pulse-play/hub build`. No code changes needed.

### Bug 3: Balance card not visible on Bettor page
**Root cause:** `AccountBalanceCard` only existed on `/account` page, not the bettor page.
**Fix:** Imported `AccountBalanceCard` into `app/page.tsx` and placed it above `PositionList` in the right sidebar.

### Test Results
- **Hub:** 212 passed (unchanged)
- **Frontend:** 182 passed (was 181, +1 new re-auth guard test)
- **Dashboard:** 33 passed (unchanged)
- **Total:** 427 passing tests
