## Phase 1 Complete: Monorepo + LMSR Engine + Market Manager + Position Tracker
Date: 2026-02-04

### What was done:
1. **Monorepo scaffolding** — pnpm workspaces with root package.json, pnpm-workspace.yaml, tsconfig.base.json, .gitignore
2. **packages/hub** — TypeScript + Jest setup with ts-jest
3. **LMSR Engine** (`packages/hub/src/modules/lmsr/`)
   - `types.ts` — Outcome type
   - `engine.ts` — Stateless LMSR functions: costFunction, getPrice, getCost, getShares (binary search inverse), getNewQuantities
   - Uses log-sum-exp trick for numerical stability with large quantities
   - `engine.test.ts` — 23 tests covering prices, costs, shares, quantities, b-sensitivity
4. **Market Manager** (`packages/hub/src/modules/market/`)
   - `types.ts` — Market, MarketStatus, ResolutionResult types
   - `manager.ts` — State machine (PENDING→OPEN→CLOSED→RESOLVED), market CRUD, resolution with position-based winner/loser calculation
   - `manager.test.ts` — 21 tests covering creation, valid transitions, invalid transitions, timestamps, resolution logic
5. **Position Tracker** (`packages/hub/src/modules/position/`)
   - `types.ts` — Position type
   - `tracker.ts` — In-memory position storage with market/user/specific queries and cleanup
   - `tracker.test.ts` — 10 tests covering add, query, clear

### Test results:
- **54 tests passing** across 3 test suites
- Command: `pnpm --filter hub test`

### Architecture decisions:
- LMSR engine is purely stateless functions (no class) — easy to test and compose
- MarketManager is a class holding market state in a Map — supports multiple markets
- PositionTracker is a class with in-memory array — simple and sufficient for MVP
- Market resolution takes positions as a parameter (loose coupling with PositionTracker)
- Binary search for getShares inverse (100 iterations, 1e-10 tolerance)

### Tech stack so far:
- pnpm 10.x workspaces
- TypeScript 5.6
- Jest 29 + ts-jest 29
- Node 20+

---

## Phase 2 Complete: Yellow Network / Clearnode Integration
Date: 2026-02-04

### What was done:
1. **Dependencies added** — @erc7824/nitrolite@^0.5.3, viem@^2.45.1, ws@^8.19.0, @types/ws
2. **Clearnode module** (`packages/hub/src/modules/clearnode/`)
   - `types.ts` — ClearnodeConfig, SubmitAppStateParams, CloseSessionParams, TransferParams, AppSessionAllocation
   - `rpc.ts` — sendAndWait() promise-based WebSocket correlator (adapted from yellow-quickstart)
   - `auth.ts` — 3-step EIP-712 auth flow: auth_request → auth_challenge → auth_verify
   - `faucet.ts` — requestFaucet() HTTP helper for sandbox token distribution
   - `client.ts` — ClearnodeClient class: connect, disconnect, isConnected, getBalance, requestFaucet, submitAppState, closeSession, transfer
   - `rpc.test.ts` — 6 tests (send, resolve, ignore, error, timeout, concurrent)
   - `auth.test.ts` — 6 tests (request, challenge, verify, signer return, request fail, verify fail)
   - `client.test.ts` — 24 tests (connection lifecycle 6, getBalance 4, faucet 2, submitAppState 4, closeSession 4, transfer 4)
   - `client.live.test.ts` — 6 live tests gated by LIVE_TEST=true (auth, faucet, balance, disconnect)
3. **Jest config updated** — Added moduleNameMapper to resolve .js imports for ESM-style TypeScript

### Test results:
- **90 mock tests passing** across 6 test suites
- **6 live tests skipped** (run with LIVE_TEST=true pnpm --filter hub test)
- Command: `pnpm --filter hub test`

### Architecture decisions:
- ClearnodeClient wraps all Clearnode operations behind a clean interface
- Auth flow generates ephemeral session keys (lightweight ECDSA for repeated RPC calls)
- sendAndWait correlates request/response by RPC method name, handles errors and timeouts
- Faucet is a standalone helper (reusable for bettor funding in Phase 3)
- Live tests use throwaway ephemeral wallets against sandbox — no cleanup needed
- Module imports use .js extensions (ESM convention) with Jest moduleNameMapper for resolution

### How PulsePlay uses these operations:
- Fund MM (test): requestFaucet()
- Bet rejected: closeSession() — return funds to user
- Loser resolution: submitAppState() (reallocate user→MM) → closeSession()
- Winner resolution: closeSession() (return bet) → transfer() (pay profit from MM→user)
- Check liquidity: getBalance() — MM's available funds

### Next steps (Phase 3):
- Hub REST + WebSocket APIs (Fastify)
- POST /api/bet, GET /api/market, POST /api/oracle/*, POST /api/faucet/*
- WebSocket broadcast for real-time odds/market updates
- Mock Oracle with auto-play mode
- Wire LMSR + Market + Position + Clearnode into API endpoints

---

## Phase 3 Complete: Hub REST + WebSocket APIs
Date: 2026-02-04

### What was done:
1. **Dependencies added** — fastify, @fastify/websocket
2. **API types** (`src/api/types.ts`) — Request/response DTOs, WebSocket message type unions (ODDS_UPDATE, MARKET_STATUS, GAME_STATE, BET_RESULT)
3. **OracleService** (`src/modules/oracle/`) — Game state management, auto-play mode with configurable timers and outcome sequences, callbacks for market lifecycle
4. **WsManager** (`src/api/ws.ts`) — WebSocket connection tracking with per-address mapping, broadcast(), sendTo(), cleanup on close
5. **AppContext** (`src/context.ts`) — Shared context interface + createTestContext() helper with mocked ClearnodeClient
6. **App factory** (`src/app.ts`) — buildApp(ctx) creates Fastify instance with all routes and WebSocket support
7. **Routes:**
   - `bet.routes.ts` — POST /api/bet (LMSR integration: getShares → getNewQuantities → updateQuantities → record position → broadcast odds)
   - `market.routes.ts` — GET /api/market, GET /api/market/:marketId (with computed LMSR prices)
   - `positions.routes.ts` — GET /api/positions/:address
   - `oracle.routes.ts` — POST /api/oracle/game-state, /market/open, /market/close, /outcome (full lifecycle with WS broadcasts + individual BET_RESULT messages)
   - `faucet.routes.ts` — POST /api/faucet/user (stub), POST /api/faucet/mm (calls ClearnodeClient)
   - `admin.routes.ts` — GET /api/admin/state, POST /api/admin/reset
8. **Server entry point** (`src/server.ts`) — Creates real context from env vars and listens on PORT

### Test results:
- **184 tests passing** across 15 test suites (90 existing Phase 1+2 + 94 new Phase 3)
- 6 live Clearnode tests skipped (run with LIVE_TEST=true)
- Integration tests use real WebSocket connections (app.listen on port 0)
- All route tests use Fastify's app.inject() — no port binding needed

### Test breakdown (Phase 3 new — 94 tests):
- oracle.test.ts: 11 (game state, auto-play, timers)
- ws.test.ts: 8 (broadcast, sendTo, cleanup, clear)
- bet.routes.test.ts: 15 (validation, LMSR integration, WS broadcast)
- market.routes.test.ts: 8 (prices, states, by-ID lookup)
- positions.routes.test.ts: 5 (query, filtering, field completeness)
- oracle.routes.test.ts: 23 (game state, open/close/resolve, WS notifications, BET_RESULT delivery)
- faucet.routes.test.ts: 6 (stub, validation, ClearnodeClient integration)
- admin.routes.test.ts: 6 (state dump, reset, auto-play stop)
- integration.test.ts: 12 (full lifecycle, concurrent bets, real WS, market cycling)

### Architecture decisions:
- AppContext is a mutable object — admin reset replaces MarketManager/PositionTracker instances in-place
- Oracle module-level marketCounter generates sequential market IDs (resettable for tests)
- WsManager uses readyState === 1 (numeric) to avoid import dependency on WebSocket constant
- Integration tests track open sockets and close them in afterEach to prevent worker leaks
- Route handlers return response objects directly (Fastify serializes to JSON automatically)

### Next steps (Phase 4):
- Frontend scaffolding (Next.js 14)
- Connect to Hub WebSocket for real-time updates
- Betting UI with LMSR price display
- Game state visualization

---

## Phase 4 Complete: Frontend Core
Date: 2026-02-04

### What was done:
1. **Next.js 14 scaffolding** — Created @pulse-play/frontend package with TypeScript, Tailwind, App Router
2. **Jest + testing-library setup** — Mock modules for wagmi, viem, @tanstack/react-query, WebSocket
3. **Lib modules** (`src/lib/`)
   - `config.ts` — env var exports (HUB_REST_URL, HUB_WS_URL, PRIVATE_KEY)
   - `types.ts` — mirrors hub API types (MarketResponse, PositionsResponse, WsMessage, etc.)
   - `api.ts` — Hub REST client (placeBet, getMarket, getPositions, oracle endpoints)
4. **Providers** (`src/providers/`)
   - `WagmiProvider.tsx` — wagmi config + QueryClient + WalletContext (address derived from PRIVATE_KEY)
   - `WebSocketProvider.tsx` — WebSocket connection management, subscribe pattern for real-time updates
   - `MarketProvider.tsx` — Market state management, syncs with REST + WebSocket
5. **Hooks** (`src/hooks/`)
   - `useBet.ts` — Bet placement with loading/error states
   - `usePositions.ts` — Position fetching with auto-refetch on market resolution
   - `useMarket.ts`, `useWebSocket.ts` — barrel re-exports
6. **Shared Components** (`src/components/`)
   - `Header.tsx` — Logo, navigation (Bettor/Oracle), WebSocket status, WalletStatus
   - `WalletStatus.tsx` — Shows truncated address or "not configured"
7. **Bettor Components** (`src/components/bettor/`)
   - `OddsDisplay.tsx` — Ball/Strike prices as percentages + American odds
   - `BetForm.tsx` — Outcome selection, amount input with presets, place bet button
   - `PositionList.tsx` — Shows user's positions in current market
   - `BetResultToast.tsx` — Win/Loss notification from WebSocket BET_RESULT
8. **Oracle Components** (`src/components/oracle/`)
   - `GameControls.tsx` — Activate/Deactivate game toggle
   - `MarketControls.tsx` — Open/Close market, Resolve with Ball/Strike
   - `StateDisplay.tsx` — System state dashboard (market, positions, connections)
9. **App Pages** (`src/app/`)
   - `layout.tsx` + `LayoutInner.tsx` — Provider nesting (WagmiProvider > WebSocketProvider > MarketProvider)
   - `page.tsx` — Bettor view (OddsDisplay, BetForm, PositionList)
   - `oracle/page.tsx` — Oracle panel (GameControls, MarketControls, StateDisplay)
10. **Hub CORS** — Added @fastify/cors to hub for frontend cross-origin requests

### Test results:
- **67 tests passing** across 15 test suites
- Command: `pnpm --filter @pulse-play/frontend test`
- Build passes: `pnpm --filter @pulse-play/frontend build`

### Test breakdown (67 tests):
- lib/api: 9
- providers: 12 (WagmiProvider 3, WebSocketProvider 4, MarketProvider 5)
- hooks: 10 (useBet 5, usePositions 5)
- components/shared: 6 (Header 3, WalletStatus 3)
- components/bettor: 17 (OddsDisplay 4, BetForm 5, PositionList 4, BetResultToast 4)
- components/oracle: 13 (GameControls 4, MarketControls 5, StateDisplay 3)

### Architecture decisions:
- WagmiProvider uses viem's privateKeyToAccount for direct wallet; no connector dependencies
- WebSocket reconnects after 3 seconds on disconnect
- MarketProvider refetches on OPEN/RESOLVED status changes (not CLOSED)
- BetResultToast uses subscribe pattern to avoid prop drilling
- All components have data-testid attributes for testing
- Test mocks for wagmi/viem/react-query avoid ESM import issues in Jest

### Environment setup:
- Copy `.env.local.example` to `.env.local`
- Set `NEXT_PUBLIC_PRIVATE_KEY` to a test wallet private key

### Running the full stack:
1. Terminal 1: `pnpm --filter hub build && node packages/hub/dist/server.js`
2. Terminal 2: `pnpm --filter @pulse-play/frontend dev`
3. Open http://localhost:3000 (Bettor) or http://localhost:3000/oracle (Oracle)

### Next steps (Phase 5):
- Remaining personas (Bettor wallet connection, proper session management)
- E2E integration tests
- Demo polish

---

## MetaMask Wallet Connection with Environment Toggle
Date: 2026-02-05

### What was done:
1. **Config update** (`packages/frontend/src/lib/config.ts`)
   - Added `WalletMode` type ('metamask' | 'private-key')
   - Added `WALLET_MODE` export from `NEXT_PUBLIC_WALLET_MODE` env var (default: 'private-key')

2. **Jest mock for wagmi/connectors** (`src/test/mocks/wagmiConnectors.ts`)
   - New mock file with `injected()` connector export

3. **Jest config update** (`jest.config.js`)
   - Added `'^wagmi/connectors$'` module mapping

4. **wagmi mock update** (`src/test/mocks/wagmiModule.ts`)
   - Added test utilities: `__setMockAccountState`, `__setMockConnectFn`, `__setMockDisconnectFn`, `__resetMocks`
   - Imports injected connector from wagmiConnectors mock

5. **WagmiProvider refactor** (`src/providers/WagmiProvider.tsx`)
   - Extended WalletContextValue interface with: `mode`, `isConnecting`, `isConnected`, `connect`, `disconnect`
   - Added `WalletContextProviderInner` component that uses wagmi hooks (useAccount, useConnect, useDisconnect)
   - Conditional logic: MetaMask mode uses wagmi hooks, private-key mode uses static account
   - Connect finds injected connector and calls wagmi connect
   - Provider nesting: WagmiProviderBase → QueryClientProvider → WalletContextProviderInner

6. **WalletStatus update** (`src/components/WalletStatus.tsx`)
   - MetaMask mode, not connected: Shows "Connect Wallet" button
   - MetaMask mode, connecting: Shows "Connecting..." disabled button
   - MetaMask mode, connected: Shows address + "Disconnect" button
   - Private-key mode: Keeps existing behavior (no connect/disconnect buttons)

7. **Tests updated**
   - `WagmiProvider.test.tsx`: 6 tests for new context fields and behaviors
   - `WalletStatus.test.tsx`: Expanded to 11 tests covering both modes

8. **Environment documentation** (`.env.local.example`)
   - Documented `NEXT_PUBLIC_WALLET_MODE` with mode options

### Test results:
- **77 tests passing** across 15 test suites (was 67)
- Command: `pnpm --filter @pulse-play/frontend test`

### Breaking changes:
- None — `useWallet()` remains backwards compatible
- `address` and `isConfigured` still work as before
- New fields (`mode`, `isConnecting`, `isConnected`, `connect`, `disconnect`) added with sensible defaults

### Usage:
```bash
# Private-key mode (default) - existing behavior
NEXT_PUBLIC_WALLET_MODE=private-key
NEXT_PUBLIC_PRIVATE_KEY=0x...

# MetaMask mode - browser wallet connection
NEXT_PUBLIC_WALLET_MODE=metamask
```

### Notes:
- Module-level config evaluation means WALLET_MODE is read once at import time
- MetaMask mode tests would require Jest module isolation (complex), so coverage is via integration testing
- WagmiProvider test file simplified to avoid react multiple-instance issues with jest.doMock


### Build fix:
- Changed import from `wagmi/connectors` to main `wagmi` export for `injected` connector
- `wagmi/connectors` barrel imports porto module which has missing peer dependency
- Removed separate wagmiConnectors.ts mock file (injected now in wagmiModule.ts)
- Removed `^wagmi/connectors$` mapping from jest.config.js

